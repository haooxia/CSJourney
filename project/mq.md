# 消息队列

- [消息队列](#消息队列)
  - [为何要用mq/作用](#为何要用mq作用)
  - [AMQP协议](#amqp协议)
  - [RabbitMQ工作模式/通讯模式](#rabbitmq工作模式通讯模式)
    - [exchange类型](#exchange类型)
  - [mq vs. 多线程异步](#mq-vs-多线程异步)
  - [死信队列是什么](#死信队列是什么)
  - [延时队列是什么](#延时队列是什么)
  - [如何保证消息的幂等性/解决消息重复消费](#如何保证消息的幂等性解决消息重复消费)
  - [mq中消息积压导致消息过期怎么办](#mq中消息积压导致消息过期怎么办)
  - [可靠性](#可靠性)

## 为何要用mq/作用

> 解耦，异步，削峰

* **解耦**：生产者和消费者不再直接交互，而是通过消息队列进行通信。某一系统的故障不会直接影响到其他系统。eg 电商平台可以在订单处理时将信息发送到消息队列，即使下游系统暂时不可用，也不会影响用户下单
* **异步处理**：许多操作不需要同步地立即完成，例如订单创建和库存更新。通过使用消息队列，这些操作可以异步进行，从而减少整体处理时间，提高性能
* **流量控制与削峰**：在高并发场景下，如秒杀活动，订单系统使用消息队列做**缓冲**，把一秒内下的订单分散成一段时间来处理，系统可以**在低峰期逐步处理这些请求**，保持稳定性，防止崩溃

## AMQP协议

AMQP协议基于TCP/IP，rabbitmq/AMQP示意图如下：

![picture 35](../images/7ceafca60fb04649b8d022064e672d6b5eb62479f4e182c4b3b7862e3abb00b3.png)  

- publisher：生产者发送消息
- consumer：消费者消费消息
- queue：队列，存储消息。生产者投递的消息会**暂存**在消息队列中，等待消费者处理
- exchange：**交换机，负责消息路由**。生产者发送的消息由交换机决定投递到哪个队列
- virtual host：虚拟主机，起到**数据隔离**的作用。每个虚拟主机相互独立，有各自的exchange、queue

## RabbitMQ工作模式/通讯模式

* **简单模式**: 一个生产者对应一个消费者，mq相当于是个代理，负责将生产者的消息传给消费者
  * eg 发送接受电子邮件(发件人-单一收件人)
* **工作队列模式(work queues)**: 一个生产者对应多个消费者，但消息只被某个消费者消费，适用于单个消费者处理不过来的场景
  * eg 一个订单需要10s处理，你不能逮着一个消费者串行地使劲薅吧
* **发布订阅模式(publish/subscribe)/fanout exchange**：一次向多个消费者发送消息，将消息将广播到所有的消费者（单生产者、多消费者、多队列(基于**fanout交换机**实现)
  * eg 更新商品库存后需要通知多个缓存和多个数据库。
* **路由模式(routing)/direct exchange**：根据Routing Key有选择地接收消息。不同的消息交给不同的队列消费（单生产者、多消费者、多队列(基于**Direct交换机**实现，队列与交换机绑定时制定一个rounting key)
* 主题模式(Topic)/topic exchange: 也是基于routing key，只不过是可以在rountingKey中使用通配符了（#和*等），而direct中rountingkey必须是多个单词，以`.`分割

![picture 36](../images/fd9d9ed9321471129a069690245a891711cf4ab038279f113e83bfc8eb37dfcc.png)  

### exchange类型

- Fanout：广播，将消息交给所有绑定到交换机的队列
- Direct：订阅，基于RoutingKey（路由key）发送给订阅了消息的队列
- Topic：通配符订阅，与Direct类似，只不过RoutingKey可以使用通配符
- Headers：头匹配，基于MQ的消息头匹配，用的较少

## mq vs. 多线程异步

* CPU消耗: 多线程异步可能存在CPU竞争，而**MQ不会消耗本机的CPU**
* 削峰或者消息堆积能力: 当业务系统处于高并发，MQ可以将消息堆积在Broker实例中，而**多线程会创建大量线程，甚至触发拒绝策略**
* 使用MQ引入了中间件，增加了项目复杂度和运维难度。
* 故而，规模比较小的项目可以使用多线程实现异步，大项目建议使用MQ实现异步

## 死信队列是什么

私信队列Dead Letter Queue (DLQ): **消费失败**的消息存放的队列

消息消费失败的原因：

* 消息被拒绝 & 不重新入队
* 消息超时ttl未消费
* 队列达到最大队列长度，最早的消息成为死信

如果队列通过`dead-letter-exchange`属性指定了一个交换机，那该队列中的死信就会投递到该**死信交换机**中，然后被路由到死信队列。可以监听死信队列中的消息做相应的处理。

可以**隔离**异常消息，避免影响正常消息，提高了**健壮**性，开发者也方便排查问题

## 延时队列是什么

延迟队列：消息进入队列后**不会立即被消费**，只有到达指定时间后，才会被消费

需求：

* 下单后，**30分钟未支付，取消订单，回滚库存**
* 新用户注册成功7天后，发送短信问候（原来如此

![picture 0](../images/e3b969917cc572571b1ebd20e6a16e0852b4948e47e0bea727eb1616ac82b590.png)  
> 可以看到：有正常交换机+正常队列 和 死信交换机+死信队列+死信消费者

在RabbitMQ中并未提供延迟队列功能。但是可以使用：**TTL + 死信队列**组合实现延迟队列的效果
Specifically：
在创建队列是设置消息在队列中的存活时间ttl，由于正常队列没有消费者，消息一定会超时进入死信队列，监听死信队列的消费者就可以获取然后执行任务
> RabbitMQ中还可以通过社区中大佬写的插件直接将普通队列改造为延时队列

## 如何保证消息的幂等性/解决消息重复消费

> 所谓幂等就是无论这个消息被消费多少次，最终结果应该是一样的，eg 支付场景下一个扣款消息，如果重复扣款，最终也只能扣一次...从消费者角度不让重复消费时一个解决方案，还有其他方案 TODO

消息重复的原因有两个：1.生产时消息重复，2.消费时消息重复。

* 生产者发送消息给MQ，在MQ确认的时候出现了网络波动，生产者没有收到确认，这时候生产者就会重新发送这条消息，导致MQ会接收到重复消息
* 消费者消费成功后，给MQ确认的时候出现了网络波动，MQ没有接收到确认，为了保证消息不丢失，MQ就会继续给消费者投递之前的消息。这时候消费者就接收到了两条一样的消息
* 由于重复消息是由于**网络原因**造成的，无法避免

解决方法（也就是说允许你生产者重复生产咯，我消费时不重复消费就行了，确实...

* 发送消息时让每个消息携带一个**全局唯一ID**，在消费消息时先判断消息是否已经被消费过，**保证消息消费逻辑的幂等性**
* 例如引入数据库或者redis：
  * 数据库唯一主键去重：主键是不能冲突的，重复的数据无法插入
  * 引入Redis**解决重复消费**问题
    * 利用Redis，首先系统生成全局唯一的id，用set操作放入Redis中
    * 如订单信息id，消费后存储在Redis中，如果下次再来，先查看Redis中是否存在，如果存在，即此消息已经被消费过（后续不做消费处理）；如果不存在，即未消费，此时再将此id存入Redis中，进行后续的逻辑操作

综上，消费过程为：

* 消费者获取到消息后先根据id去查询redis/db是否存在该消息
* 如果不存在，则正常消费，消费完毕后写入redis/db
* 如果存在，则证明消息被消费过，直接丢弃

## mq中消息积压导致消息过期怎么办

* 如果消息在queue中积压超过一定的时间就会被rabbitmq给清理掉，这个数据就没了
* 解决方案：**批量重导**。就是大量积压的时候，我们当时就直接丢弃数据了，然后等过了高峰期以后，这个时候我们就开始写程序，**将丢失的那批数据，写个临时程序，一点一点的查出来，然后重新灌入mq**里面去，把白天丢的数据给他补回来。
  * 假设1万个订单积压在mq里面，没有处理，其中1000个订单都丢了，你只能手动写程序把那1000个订单给查出来，手动发到mq里去再补一次

## 可靠性

https://blog.csdn.net/sluck_0430/article/details/136266002