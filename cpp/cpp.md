# CPP

[toc]

## 注意事项

1. 每个程序/项目必须有一个命名为main的函数，main函数返回类型必须是int，因为有的编译器不支持void main，且返回值用来指示状态，非0返回值由系统定义指示错误类型。
2. 执行完cpp程序后，可以使用echo $获得返回值（linux）
3. 标准库iostream包括cin, cout, cerr, clog, <<左边必须是一个ostream对象，如cout, ceer，输出流返回结果依然是ostream对象。
4. 16bit <= short <= int <= long(>32) <= long long(>=64)
5. 当一个表达式中既有unsinged又有int时，int会被转换为无符号数。
6. 字面值常量：整数字面值(8)、浮点数字面值(8.0)、字符字面值('a')、字符串字面值("hello")、布尔字面值(false)、指针字面值(nullptr)、转移序列；
7. 初始值不是赋值，初始值是创建变量时赋予一个初始值；赋值是把对象的当前值擦除，再以一个新值替代。
8. cpp11引入了列表初始化，(eg int a{0})，它还能给对象赋新值；初值存在丢失风险的时候会报错(p39)；
9. 默认初始化：函数体内的内置类型若未初始化，则值未定义（不在定义控制范围之内）；定义于任何函数体之外的变量被初始化为0；

## 正文

```c
// 64bit os
typedef long unsigned int size_t;
typedef long ssize_t;
// 32bit os
typedef unsigned int size_t;
typedef int ssize_t;
```

如果要迁移，只需要修改一下typedef定义即可，美滋滋；
所以一般喜欢给基本数据类型起别名，_t一般是os起的；

0.about void*:

- 任何类型的指针都可以直接赋值给void*指针， 且无需进行强制类型转换。
- void*赋值给其他类型的指针需要进行显式转换.
- void指针只有强制类型转换后才可以正常对其操作，即强制类型转换后才有意义，比如int a=1; void* t = &a; 不能直接deference，得*((int*)t)
- void指针可以直接和其他类型的指针进行比较指针存放的地址值是否相同

1. **c语言有哪些核心的特征？**
简便灵活；可移植性好；可直接操作计算机硬件；执行速度快；可扩展性很强。

2. **c语言中有哪些基本的数据类型？**
Int整型。Float浮点型。Double双浮点型。Char单个字符。void特殊类型，不包含任何值

3. **解释一下语义错误syntax error。**
在写程序的时候会有很多语义错误，比如说，拼错了命令，一个函数的参数个数错了， 数据类型不匹配，等等。

4. **描述一下静态函数的用途。**
使用静态static关键字定义的函数称之为静态函数。
静态函数会被自动分配在一个一直使用的存储区，直到退出应用程序实例，避免了调用函数时压栈出栈，速度快很多。

5. **说一下wild pointers（野指针/迷途指针/空指针）**
野指针是指指针指向的位置是不可知的，指针变量在定义是若未初始化，其值是随机的。这些指针指向一个随意的内存地址。如果访问它们可能会导致程序崩溃。

6. 指针加减一个int 是指将该指针的值（地址），和他指向的变量所占用的内存单元字节数相加减。eg double*p;p++(p+sizeof(double)(即8)) 使指针指向当前对象的下一个对象。

7. 区别
   1. 常量指针：const 修饰指针，**const** int *p=&a;指针指向的值不可更改。可用于作为参数传入函数时保护数组的值不被改变const int a[];
   2. 指针常量：const修饰常量，**int *** const p =&a;指针的指向不可改变。
   3. 注：**1.指针和const 谁在前先读谁。2.*代表地址(指向)，const代表内容(指向的值)。3.谁在前谁就不许改变。**
8. **++a和a++的区别是什么?**
++a的意思是先加后取值。A++的意思是先取值后增加。

9. **解释一下c语言的函数原型。**
原型函数是对一个函数的声明。
它包含函数名，返回值和参数类型列表。可不包含参数名。对应着函数体。
10. **说一下c语言的头文件（库文件）和用途。**
    头文件存放了函数原型的定义。这个文件又称为库文件。
    比如说printf和scanf存放在stdio.h里面。

11. **解释一下在调试过程中对代码进行注释的做法。**
这个做法称为commenting out。通过把一些代码屏蔽掉来判断或排除是否是这些代码造成的错误。

12. **C语言中循环的类型**
for（如果固定次数）、do while（如果必须执行一次）、while（其他情况）

13. **什么是nested loop（嵌套循环）?**
    一个循环包含在另一个循环中称为nested loop。第1个循环成为外循环。里面的循环称为内循环。内循环执行的次数作为总循环的次数。

14. static
    1. 静态局部变量：该变量生存期，不改变作用域。static关键字只初始化一次，下一次依据上一次结果值。
    2. 静态全局变量：非静态全局变量在一个源程序的各个源文件都有效，加static限制了作用域，只在定义该变量的源文件中有效。
    3. static函数：
       1. 经static修饰后不可跨文件调用函数
       2. 分在一个一直使用的存储区

15. **c语言中函数的通常格式是怎样的？**
    C语言的函数，包含4个部分。
    返回值， 函数名， 参数， 函数体。

16. **什么是指针的指针?**
    指针的指针是指一个指向指针所在地址的指针。

17. **Break关键字在哪个地方使用?Continue呢？**
    Break可以用在循环中和switch语句当中。是用来终止当前的循环或跳出switch。

    Continue用于结束本趟循环中剩下尚未执行的语句，继续执行下一次循环。

18. **如何向栈数据结构里面存储数据?**
    这样的数据是先进后出的。只有顶部的数据才可以被访问到。

19. **C程序算法的意义是什么?**
    提高程序的执行效率，设计算法时主要要考虑算法的时间复杂度和空间复杂度。

20. **描述一下modifier。**
    Modifier是数据类型的前置，用来标识存储空间的大小。

    比如说在32位处理器系统中, 整形的长度为4B。

    如果我们加了如下的modifier:

    Long Int 就可以存8 B。Short Int 占 2 B。

21. **在c语言中有哪些modifiers?**
    Short、Long、Signed、Unsigned、long long

22. **能不能在整型中存放32768这个数?**
    Int：-21亿-21亿

23. **什么是indirection（间接）?**
    如果你定一个指针变量， 它指向一个值变量或者一个内存对象。在这种情况下，对这个值变量和对象来说没有一个直接的引用。这种情况就是indirection.

    但是如果我们声明一个变量，它对值来说就是一个直接（direct）的引用。

24. **在c语言中，什么时候会用到空指针?**
    作为一个错误值。作为一个监测值。在一个递归数据结构中终止indirection。

25. **解释一下模块化编程。**
把主程序分成多个小的，可执行的模块称为模块化编程。这个概念是为了增强重用性。同时也提高了程序的可维护性。

26. **Call by value**和**call by reference有什么区别?**
按值传递与按地址传递。按值传递不会改变调用处的值，会形成一个副本，而按地址传递不会形成副本，会改变原处的值。

27. **如何在c语言中定义一个字符串变量？**
使用char定义一个字符数组。
Char *str=”hello”;（指针形式，这个字符串**常量**存在只读区域，不可修改）
Char str[] = “hello”；（数组形式，如需修改字符串，采用数组形式）

28. **什么是preprocessor directives/instructions（预处理指令）?**
Preprocessor directives一般放在程序的开头。主要是用来指定调用库文件的。还有一个用途是用来定义一些常值变量，宏定义等等。#开头。

29. **C语言的一些字符A串函数：**
Strlen(s)返回长度；
strcmp(s1,s2)按ASCII比较s1和s2的大小
Strcpy(s1,s2)将s2拷贝到s1；（没strncpy安全）
strcat(s1,s2)将s2拼接在s1后面concatenate（没strncat安全）

30. **这样赋值对不对？错在哪里?**
myName="test";不对。C语言可没重载string的赋值号。需要使用strcpy。

31. **为什么c语言被认为是中级语言?**
因为c语言既能像高级语言那样编写程序，又可以像低级语言如汇编那样直接操作硬件。

32. **描述一下c程序的运行过程？**
源程序(hello.c )->可执行文件(hello)
    1. 预处理阶段（预处理器cpp）：对#开头的命令进行处理，eg `#include <stdio.h>`将.h文件插入程序。输出文件hello.i;
    2. 编译阶段（编译器ccl）：**翻译**生成汇编语言源程序hello.s；
    3. 汇编阶段（汇编器as）：将hello.s**翻译**成机器指令，打包成一个可重定位目标文件hello.o；
    4. 链接阶段（链接器ld）：将多个可重定位文件和标准库函数**打包**为一个可执行目标文件hello.exe

33. **什么是二叉树?**
二叉树是链表的延伸。它的每一个节点都有两个指针，一个指向左，一个指向右。（一般如此，也有数组实现的二叉树好像）

34. **什么是输出重定向？**
输出重定向是指把程序的输出，除了输出在屏幕上以外的另外选择， 比如说，输出到一个文件里。

35. **本地变量与全局变量**
全局变量具有全局的生存期和作用域，本地变量的生存期和作用域在块内。
外部变量（全局变量）和静态变量默认被初始化为0（发生在main函数之前），而局部变量（本地变量）不会被默认初始化。
**静态本地变量**（加static）是特殊的全局变量，和全局变量存在同一块内存区域。
静态本地变量作为静态变量有全局的**生存期**，作为本地变量有本地的**作用域**，只在函数内部可使用。

36. 寄存器变量
使用频率高，放在寄存器中更快

37. **Extern关键字的作用**
在需访问全局变量的函数中，可以用extern显式声明相应的外部变量，也可通过上下文隐式声明

38. **文本文件和二进制文件的区别是什么？**
文本文件存放的是人类可以阅读的内容，它包含字母数字和其他的字符。
而二进制文件存放的是1和0，只有电脑才能够读懂。

39. **如何把字符串变成数字？**
Atoi（ascii to integer）stoi(string to int)
Atof（ASCII to float）

40. C语言的赋值操作的返回值是 赋值后左边变量保存的值，所以可以将赋值表达式放到一个更大的表达式中。While((c=getchar())!=EOF))//赋值号优先级低于!=，要加括号。

41. 关系运算符 优先级高于赋值运算符 低于算数运算符。

44. ASCII常见：数字0-9:30-39；A-Z:65-90; a-z:97-122;

45. **预处理**：#define name value 名称只能是单词，可以带参数  值可以是int string 甚至可以是一条执行语句

    1. eg #define MAX(a,b) ((a)>(b)?(a):(b));//带参数的宏指令 **参数出现的所有地方都需加括号**

46. **#include时<>与“ ”区别：**

    1. “ ”要求编译器先在当前目录（.c文件所在目录）寻找，若未找到，再去编译器指定的位置
    2. <>编译器只在系统指定目录寻找（一般标准库用<> 自己的.h文件用"")

47. #ifndef #define #endif的目的是 防止头文件重复包含和编译，与#pragma once作用一致

48. **内存泄漏**：用动态存储分配函数动态开辟的空间，在使用完毕后未释放，结果导致一直占据该内存单元即为内存泄露。

49. **引用和指针的区别：**

    1. 引用底层是通过指针实现的；
    2. 指针是一个实体，需要分配内存空间。引用只是变量的别名，不需要分配内存空间。
    3. 引用在定义的时候必须进行初始化，并且不能够改变。指针在定义的时候不一定要初始化，并且指向的空间可变。指针可指向NULL，引用不行。
    4. 有多级指针，但是没有多级引用，只能有一级引用。
    5. 指针和引用的自增运算结果不一样。（指针是指向下一个空间，引用时引用的变量值加1）
    6. sizeof 引用得到的是所指向的变量（对象）的大小，而sizeof 指针得到的是指针本身的大小。
    7. 引用访问一个变量是直接访问，而指针访问一个变量是间接访问。

50. **c与c++的区别：**

    1. C是面向过程的语言，而C++是面向对象的语言
    2. C和C++动态管理内存的方法不一样，C是使用malloc/free函数，而C++除此之外还有new/delete关键字；malloc和free是标准库函数，new和delete是c++的运算符。
    3. C没有类的概念，C中的struct可在C++中正常使用的，并且C++对struct进行了进一步的扩展，使struct在C++中可以和class一样当做类使用，而唯一和class不同的地方在于struct的成员默认访问修饰符是public,而class默认的是private;
    4. c++支持函数、运算符重载、模板，有引用，c没有。

51. **面向过程与面向对象**：面向过程让计算机有步骤地顺序做一件事，是过程化思维，使用面向过程语言开发大型项目，软件复用和维护存在很大问题，模块之间耦合严重。面向对象相对面向过程更适合解决规模较大的问题，可以拆解问题复杂度，对现实事物进行抽象并映射为开发对象，更接近人的思维。

52. **面向对象的三大特性？**
    1. **封装**：把客观的事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的类进行信息的隐藏。使用者只要知道对象可以做什么就可以了，不需要知道具体是怎么实现的。封装解决了数据的安全性。
    2. **继承**：指的是建立一个新的派生类，从一个或多个基类中继承数据和函数，可以重新定义或加进新数据和函数。
    3. **多态**：同一个操作，作用域不同的对象，将产生不同的执行结果。“父类的指针或引用指向子类对象会产生多态，子类必须重写父类中的纯虚函数”；便于面向借口变成，降低耦合度。

53. C++的容器（STL库常见容器）
    1. 顺序容器（同期不自动排序，你指定在哪就在那儿）：可变长动态数组Vector、双端队列Deque（双端可进出）、双向链表list；
    2. 关联容器（容器自动排序）：set、multiset、map、multimap（多重映射）
    3. 容器适配器：stack、queue、priority-queue

### C++内存管理

1.C++语言的内存布局

|区域（地址从下到上增长）|功能|
| ----------- | ---------------------- |
| 栈区（向下增长）| 由编译器自动分配释放，存放函数的参数值和返回值、局部变量等  |
| 堆区 （向上增长）| 存放动态分配的变量；由程序员分配释放，若程序员不释放，程序结束时由os统一回收（遇到长时间运行的程序就不太好了）|
| 全局/静态区 | 存放全局变量和静态变量(static)，该区域的数据在程序结束后由os释放 |
|常量区（常量区也常常被合并到全局/静态区）|如字符串常量|
| 代码区  | 存放程序的二进制代码，由os进行管理 |

栈和堆都是内存内的一块区域，都用来存储程序数据。

| | 栈stack | 堆heap |
|-|---|---|
|功能| 存储局部变量、函数调用信息 | 存储程序运行时动态分配的数据|
|分配方式|自动分配与释放（静态内存分配）|手动分配和释放内存new/delete/malloc/free|
|变量生命周期|等同于所在函数的执行周期|由程序员显示控制|
|地址|高地址向低地址发展（即栈顶元素地址是最低的）|相反|

2.内存泄漏(memory leak)是指由于疏忽或错误造成了**程序未能释放掉不再使用的内存**的情况。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，**失去了对该段内存的控制**，因而造成了内存的浪费。
> 即：指针指向改变，未释放动态分配的内存。
> 预防方式：将内存的分配封装在类中，构造函数分配内存，析构函数释放内存；使用智能指针；
> 内存泄漏意味着，即使这些内存不再被程序使用，它们也不会自动变为可用状态（存疑），直到程序结束时才会被操作系统回收。

3.内存泄漏分类

- 堆内存泄漏 heap leak: 没有free或delete的内存块；
- 系统资源泄露 resource leak: 程序使用系统分配的资源比如文件句柄handle, socket等没有使用相应的函数释放掉；
- 没有将基类的析构函数定义为虚函数：当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确是释放，因此造成内存泄露。（没懂）

4.智能指针是为了解决动态分配内存导致内存泄露和**多次释放**(?)同一内存所提出的，C11标准中放在< memory>头文 件。包括:共享指针，独占指针，弱指针。

## 基础

1.main函数执行之前和之后会做什么

main函数执行之前，主要就是初始化系统相关资源：

- 设置栈指针
- **初始化**static静态变量和global全局变量; (.data段的内容)
- 将**未初始化**部分的全局、静态变量赋初值：初始化为0/False/NULL; (.bss段的内容)
- **全局对象**初始化，在main之前调用构造函数
- 将main函数的参数argc，argv等传递给main函数，然后才真正运行main函数
- `__attribute__((constructor))`

main执行之后

- 执行**全局对象**的析构函数
- 可以用atexit注册一个函数，它会在main之后执行;
- `__attribute__((destructor))`

2.结构体内存对齐
内存对⻬是指数据在内存中的存储起始地址是某个值的倍数。

为什么要进行内存对齐？我们知道内存是以字节为单位，但大部分cpu并不是按字节块来存取内存的，一般是可能是2,3,8,16byte，称作内存存取粒度。有了内存对齐之后cpu可以减少读取数据次数，提升效率。

基础只是：
首先每个编译器都有默认对齐模数，gcc中默认#pragma pack(4)
有效对齐值：是给定值#pragma pack(n)和**结构体中最长数据类型**长度中较小的那个。有效对齐值也叫**对齐单位**。
对齐规则：
(1) 结构体第一个成员的偏移量（offset）为0，以后每个成员相对于结构体首地址的offset都是**该成员大小与有效对齐值**中较小那个的整数倍，如有需要编译器会在成员之间加上填充字节。
(2) 结构体的总大小为有效对齐值的整数倍，如有需要编译器会在最末一个成员之后加上填充字节。
