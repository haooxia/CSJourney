# 计算机网络笔记

- [计算机网络笔记](#计算机网络笔记)
  - [一、基础](#一基础)
    - [分层](#分层)
    - [输入UTL到页面展示发生了什么](#输入utl到页面展示发生了什么)
      - [概括](#概括)
      - [HTTP](#http)
      - [DNS](#dns)
      - [协议栈](#协议栈)
        - [3.1 TCP](#31-tcp)
        - [3.2 IP](#32-ip)
        - [3.3 MAC](#33-mac)
      - [网卡](#网卡)
      - [交换机](#交换机)
      - [路由器](#路由器)
      - [服务器](#服务器)
  - [二、HTTP](#二http)
    - [基础](#基础)
      - [GET与POST](#get与post)
      - [HTTP缓存](#http缓存)
      - [HTTP/1.1特性](#http11特性)
      - [HTTPS](#https)
  - [三、TCP](#三tcp)
    - [TCP基础](#tcp基础)
  - [四、IP](#四ip)
    - [IP address](#ip-address)
    - [IP related protocol](#ip-related-protocol)
      - [dns](#dns-1)
      - [ARP](#arp)
      - [DHCP](#dhcp)
      - [NAT/NAPT](#natnapt)
      - [ICMP/ping/traceroute](#icmppingtraceroute)
      - [IGMP](#igmp)
  - [二、物理层](#二物理层)
  - [三、数据链路层](#三数据链路层)
  - [四、重点](#四重点)
  - [other](#other)


## 一、基础

### 分层

OSI七层结构
TCP/IP四层参考模型：应用层（上三层），传输层，网络层，网络接口层（下两层）
我更喜欢五层模型。数据链路层管mac，分离出来还是挺好的。

![picture 0](../images/38d98be16bd0cfa551b6469ba2891c1a5180c4170d899cb2dc264cd3790ff7b1.png){width=70%}  

七层协议详解（可以直接忽略表示层、会话层，然后合并下两层）

1. **应用层Application Layer** ：为**特定应用程序**提供数据传输服务，e.g., HTTP, FTP, Telnet, DNS, SMTP, SSH等。数据单位为==报文==。
    1. 应用层工作在os的用户态，传输层及以下工作在内核态。
2. 表示层 ：**设备固有数据格式和网络标准数据格式的转换**，接受不同形式的信息，文字图像声音等。
3. 会话层 ：通信管理，负责**建立和断开通信连接**(数据流动的逻辑通路)；
4. **传输层Transport Layer** ：负责不同主机中两个**进程**之间的通信（通过**端口**）。
    1. 由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的应用层协议。
        1. 传输控制协议 TCP：提供面向连接、**可靠的数据传输服务**.(特性：流量控制、超时重传、拥塞控制).数据单位为==报文段(TCP Segment)==；e.g., HTTP.
        2. MSS: TCP最大报文段长度
        3. 用户数据报协议UDP：提供无连接、尽最大努力的数据传输服务，数据单位为==用户数据报==。TCP 主要提供完整性服务，UDP 主要提供及时性服务。
5. **网络层Internet Layer** ：负责两台**主机**之间的通信，也叫点对点通信(end-to-end)。将数据传输到目标地址，目标地址可以是多个网络通过路由器连接的而成的某一个地址，负责**寻址和路由选择**。
    1. IP协议将传输层的报文段作为数据部分，加上IP包头组装为IP==分组==。IP分组>MTU将进行分片(以太网=1500B)。
    2. ![picture 7](../images/1f9ec8a9d482d2377f84ed9f812f1df649903bd922d7ca8929a0361d92cea261.png){width=80%}
    3. IP协议两个功能：**寻址和路由选择**（区别在哪？）
6. **数据链路层(MAC层)** ：负责物理层面上的**直连**的设备之间的通信。网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成==帧==。PPP Ethernet
    1. 网络层是source address -> target address，数据链路层仅负责其中的一个个区间内的通信。
7. **物理层** ：负责物理介质上实现0,1比特流与电子信号的互换与传输。考虑的是怎样在传输媒体上传输数据==比特流==，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。

MAC地址：网卡(NIC)设备出厂会烧一个唯一MAC，其层次性对寻址没用，可以不算有层次性；MAC寻址参考地址转发表；
IP地址：网络号+主机号；具有层次性；IP寻址参考路由控制表；

![picture 2](../images/546a3eb0a30aacda3b1e23cbb4a26277d6b5805460445b2ebbae5bba1ebd1ddc.png){width=80%}

---

### 输入UTL到页面展示发生了什么

#### 概括

1. 浏览器接收用户请求，**先检查浏览器缓存**中是否缓存该资源，如有直接返回，如无进入下一步网络请求。
2. **网络请求前，进行DNS解析**，以获取请求域名domain的IP地址；如果请求协议是HTTPS，还需要建立**TLS链接**。DNS解析时会按照本地浏览器缓存 -> 本地Host文件 -> 路由器缓存 -> DNS服务器 -> 根DNS服务器 的顺序查询域名对应IP，直到找到为止。
3. **浏览器和服务器==IP==建立TCP连接**。连接建立后，浏览器端会构建请求行、请求头等信息，并把和该域名相关的Cookie等数据附加到请求头中，向服务器构建请求信息。
4. 服务器接收到**请求**信息，根据请求生成**响应数据**。
5. 浏览器解析响应头。若响应头状态码为301、302，会重定向到新地址；若响应数据类型是字节流类型，一般会将请求提交给下载管理器；若是HTML类型，会进入下一部**渲染流程**。
6. 浏览器解析HTML文件，创建DOM树，解析CSS进行样式计算，然后将CSS和DOM合并，构建渲染树；最后布局和绘制渲染树，完成⻚面展示。

#### HTTP

   1. (浏览器)解析URL得到Web服务器和文件名
   2. 生成HTTP请求消息

![picture 3](../images/a966fa0b2e0e10f7ca5669428565261871e16afad75096476ca63be9ee655354.png){width=80%}

所以常常的URL实际上就是请求Web服务器中的文件资源。

HTTP消息
![picture 1](../images/07e11be6123eb184c6490e0ff448fd2bbb40ac3129fc1c99620db0009a069225.png){width=70%}
![picture 0](../images/9a11cac59ee1a711c1509e454894ac1b7c5951f447fbaa505ee74f0488da0e38.png){width=70%}

#### DNS

浏览器解析URL生成HTTP消息后，需要委托os将消息发送给web服务器(基于IP)。但在发送之前，需要查询服务器域名对应的IP地址。

DNS(Domain Name System)服务器专门保存了web服务器域名与其ip之间的映射，是一种服务器。
> 域名用·分隔，越靠右层级越高(老外总喜欢反着来)

实际上www.google.com完整形式是www.google.com.; 域名层级关系为:

1. **根域名**DNS服务器(.): Root DNS Servers
2. **顶级域名**DNS服务器(.com): Top-Level Domain(TLD) Servers
3. **权威域名**DNS服务器(google.com): Authoritative DNS Servers
4. 递归域名服务器(本地域名服务器)：Recursive DNS Servers，负责向其他DNS服务器查询映射信息，给到用户。

> 根域的DNS服务器信息存在互联网的所有DNS服务器中。故而所有DNS服务器都可找到根域DNS服务器，一路向下顺藤摸瓜就找到了目标DNS服务器。

讲解域名解析的过程：
![picture 2](../images/eaf1523c5e51050835cc3abaa157310c2cd7ca460ca9c3124430fbddc38a22c6.png)  
> 本地DNS服务器就是递归DNS服务器，一般可能在运营商那。
> DNS解析中**缓存查询**：先查询浏览器缓存 -> 查询操作系统缓存 -> 查询Hosts文件 -> (路由器缓存、ISP缓存) -> 都没有才去问本地DNS服务器

#### 协议栈

通过DNS获取IP之后，就可以把HTTP传输工作交给**操作系统中**的协议栈了。
![picture 3](../images/92c260712371e4d925336283e8a0b47f961907ac7bcfd17e7c6ef38fab85311f.png){width=70%}

- 应用程序调用socket来委托协议栈工作
- 网卡驱动程序负责控制网卡硬件，网卡负责对网线中的信号执行发送和接受操作

协议栈中一步步来咯

##### 3.1 TCP

http基于tcp。

如果HTTP请求消息过长，超过MSS，TCP会对其进行分割。然后加上TCP头部(源端口是浏览器客户端随机的，目标端口为80(http)或者443(https))。
此时请求报文位于tcp报文的数据部分，**封装的很安全可靠了**，可以发送了。

##### 3.2 IP

可是发给谁呢，TCP头部目前只有port，需要搞个目标主机的地址啊。ip来整远程定位吧。

老规矩，讲解IP报文头部格式：
![picture 8](../images/5f8286a1a030393169bcfa23ecf28c93649fd5fb79e7c7156ca18a2073f4335c.png){width=80%}

ok，现在网络报的报文为：
|IP头部|TCP头部|HTTP报文(HTTP头部+数据)|
|------|------|----------------------|

##### 3.3 MAC

ok，挺好的，ip帮我远程定位到**最终**目标地址了，可是好远啊，我下一站去哪儿呢？需要一个**两点传输**助手：MAC。

> 注意MAC功能属于IP层(arp)，不是网卡控制的奥。

老规矩，上MAC头部：
![picture 10](../images/8dfab644c4e9cd5276a096001a4ad9b09c3bdc97d6c20f9a1a7fde819fba7a7d.png){width=80%}

发送方MAC：从网卡读一下
接收方MAC：（有点复杂，交给ARP）

ARP地址解析协议：IP->MAC; `arp -a`
若同一个局域网中的主机A给B发数据，先查询**ARP缓存**(就几分钟...)中有无B的IP，若有，相应mac写入mac帧发送即可；
若无，发送**帧广播ARP请求分组**：目的MAC地址为FF-FF-FF-FF-FF-FF，目的ip也已知。主机B收到请求后，向A单播一个包含自己mac的ARP应答分组。

知道了目标ip对应的MAC之后，就确定了下一站地址（交换机内部维持一张mac->端口的映射表(此处的端口真的是交换机上的物理端口)）也即**以太网内的传输是基于mac的**。

> ARP请求/应答报文 = 发送端mac + 发送端IP + 目的端mac + 目的端ip

ok，现在网络报的报文为：
|MAC头部|IP头部|TCP头部|HTTP报文(HTTP头部+数据)|
|----|------|------|----------------------|

> question: why we need MAC addr? 

#### 网卡

我们的网络包是一堆二进制数据，无法直接发给对方，需要将**数字信号转为电信号**，才能在网线上传输，即真正的传输。**网卡**要登场了。在网卡之前，还有**网卡驱动程序**。

首先，**网卡驱动**获取网络包之后，会将其**复制**到**网卡内的缓存区**中，接着会在其开头加上**报头**和**起始帧分界符**， 在末尾加上用于检测错误的**帧校验序列**。

![picture 11](../images/e4e7e421d7be0b423b7069a0cda4b368c86fffbdbb4159d75b2eed8322546ac3.png){width=80%}

==到此，真的是封装完毕了==！交给网卡转为电信号发出去了。

#### 交换机

交换机位于MAC层(**数据链路层**)，二层网络设备。**交换机的端口没有mac地址。**

网线上电信号来到交换机，将其转换为数字信号。根据FCS进行错误校验，若没问题，放到交换机缓冲区内。（无法判断mac所以没出错的话统统接受）

交换机内部维持着一张**mac地址表->端口之间的映射表**。据此，就可以知道要发给目标mac电脑要走哪个端口。如果映射表中没找到，只能转发到除了源端口以外的所有端口，非目标机自动丢弃。（目标机响应的时候可以记录下映射）

> 集线器hub是无脑将收到的电信号广播给所有出口。很呆，所以是一层网络设备(物理层)。接收方主机通过mac地址进行判断是不是发给自己的。
> 交换机是将收到电信号只发给**目标mac指定的电脑对应的出口**。有点聪明，定义到二层网络设备(数据链路层)。

#### 路由器

网络包经过交换机后到达路由器，将会转发给下一个路由器或目标设备。
路由器基于ip(网络层)，三层网络设备，**路由器的各个端口都具有MAC地址及IP地址**。
交换机基于以太网，二层网络设备，各个端口没有mac。由于路由器端口具有mac，故而可以成为以太网的发送方和接收方。各个端口的ip使其某种意义上和计算机内网卡一样。

路由器端口作为接收方收到以太网包后，根据**路由表**查询转发目标，再由相应的端口作为发送方将以太网包发出去。

Specifically，接收以太网包，开始类似于交换机，将电信号**转为数字信号**，然后进行**FCS校验**。此外，**检查头部的目的mac地址**是不是自己，如果是，放到路由器缓冲区中。不是，直接丢弃，交换机没这功能。

然后mac地址的使命结束（mac头部的作用就是将包送给下一个路由器），那么**去掉mac头部**，然后根据ip头部进行转发。

**如何转发ip包呢？**
![picture 12](../images/f20b24bf718d2d5b24c356027df2063085c7e583a8fbd95431651a7dfc9faf54.png){width=80%}
> `route -n`或者`netstat -r`查询路由表

1. 查询路由表判断转发目标。
   1. 路由匹配：根据目标ip查询路由表的目标地址列，将目标ip与每个条目的的子网掩码进行与操作，如匹配，将该路由器端口作为转发目标。如果没匹配的，选择默认路由`0.0.0.0`.
2. 路由器发送包（**仅修改mac头部(因为以太网内的两个设备传递依靠mac)，不动ip头部**）
   1. 根据路由表的网关列(gateway)判断对方的ip地址（**路由器不修改包内两端的ip奥**）。网关列显示了需要把数据包发送给哪个ip才能到达目标网段
      2. 如果目标网络在本地网段内，网关列可能显示0.0.0.0或空，表示直接可达。
      3. 如果网关列有个ip地址，说明还没到，这个ip是下一跳网关，数据包需要先到这个网关，然后再进行转发。
   2. 知道了ip之后，使用arp查到mac作为目标mac(路由器也有arp缓存)，本地mac使用路由器该端口的mac。**修改mac头部**之后将包转为电信号通过端口发送。
3. 如此经过多个路由器后，网络包到达最终网段。

![picture 13](../images/e7fb0a8562dc9e5db7d411c6dedf7f0c23538c1353024bde1dab52cb2bec6844.png)  

> 交换机转发过程中会修改mac，不修改ip，也会重新计算尾部fcs；我感觉头尾网卡负责的部分可能都需要修改，但我不确定:)

#### 服务器

网络包到达服务器后，先检查mac头部看看mac匹配否，匹配就收下。（要FCS校验吗？）然后看看ip头部的协议项，知道了上层是tcp协议，然后看看tcp头部，看看里面的序列号是不是想要的，是就放到缓存，返回一个ACK，不是则丢弃。此外，由于服务器的HTTP在监听80，如果tcp头部端口是80，服务器就把包发给http进程了。

HTTP进程看到这个请求是要访问一个页面，于是就把这个网页封装在HTTP响应报文里。响应报文也需要穿上相应的TCP、IP、MAC头部。完事儿后从网卡出发->交换机->路由器-> ... ->客户端那边的路由器->交换机->客户端->开始扒掉头部剩下http响应报文->交给浏览器渲染webPage，over！

最后，客户端要离开了，双方四次挥手断开连接（沟通一次真的挺累的。

## 二、HTTP

HTTP (HyperText Transfer Protocol)超文本传输协议
什么是超文本？是文字、图片、视频、**超链接**的混合体，HTML是常见的超文本，本身只是纯文字文件，但内部用很多标签定义了图片、视频等的链接，再经过浏览器的解释，呈现给我们的就是一个文字、有画面的网⻚了。

### 基础

HTTP常见状态码（详见p64 xiaolin）：
![picture 14](../images/1870ad5c98a9bc7c173991a3e7c745e7e10fc53260ca161558fbec49a228aca1.png){width=80%}

HTTP常见字段有：（暂略）

#### GET与POST

GET 的语义是从服务器获取指定的资源。浏览器限制url长度。
POST 的语义是根据请求负荷（报文body）对指定的资源做出处理。可以将任意格式的数据写在报文body中，浏览器不限制body大小。

安全：请求方法不会破坏服务器上的资源
幂等：多次执行相同的操作，返回的结果相同
RFC(Request for comments)规范如下（但程序员未必遵守...）：
![picture 15](../images/682943c51bfede90e23efd276ef1bbe70600a6999bdd64d47e7c86fc84fa06b5.png){width=80%}

#### HTTP缓存

对于一些重复性的HTTP请求，可以把这对「请求-响应」的数据都缓存在本地。HTTP缓存有两种实现方式：强制缓存和协商缓存。

强制缓存：只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存，决定是否使用缓存的主动性在于浏览器这边。(from disk cache)。强制缓存在response header设置两个字段表示资源在客户端缓存的有效期：相对时间Cache-control和绝对时间Expires.

协商缓存：通过服务端告知客户端是否可以使用本地缓存的资源，通过`304`状态码表示。
实现方式一（基于时间）：Last-Modified和If-Modified-Since
实现方式二（基于标识，优先级更高）：Etag和If-None-Match

协商缓存这两个字段都需要配合强制缓存中 Cache-Control 字段来使用，只有在未能命中强制缓存的时候，才能发起带有协商缓存字段的请求。
![picture 16](../images/39c61d9776cdf7d8cb6d0f454eb2d4f1606b4ec6b58794c0c166444387377147.png){width=80%}
> question: 很多cache-control设置为1年，那么一年内都不会更新？有图可知当过期后才回去更新似乎。

#### HTTP/1.1特性

- 优点
  - 简单：报文格式header+body; header中key-value
  - 灵活，易于扩展：http在应用层，下层可以任意变化
    - HTTPS：在HTTP与TCP层之间增加了SSL/TLS安全传输层
    - HTTP/1.1和HTTP/2.0传输协议使用的是TCP协议，而到了 HTTP/3.0传输协议改用了UDP协议。
  - 跨平台、应用广泛
- 缺点
  - **无状态**
    - 好处：服务器不会去记忆HTTP的状态，减轻负担。
    - 坏处：服务器没有记忆能力，它在完成有关联性的操作时会非常麻烦。so cookie诞生。
      - Cookie通过在**请求和响应报文**中写入Cookie信息来控制客户端的状态。
      - 在客户端第一次请求后，**服务器会下发一个**装有客户信息的「小贴纸」，后续客户端请求服务器的时候，带上「小贴纸」，服务器就能认得了。
  - **明文传输** -> so HTTPS
    - 好处：方便阅读和调试
    - 坏处：信息裸奔
  - **不安全**
    - 窃听风险：**通信使用明文**（不加密），内容可能会被窃听。比如，账号信息容易泄漏，那你号没了。
    - 篡改风险：**无法证明报文的完整性**，所以有可能已遭篡改。比如，网⻚上植入垃圾广告，视觉污染，眼没了。
    - 冒充风险：**不验证通信方的身份**，因此有可能遭遇伪装。比如，访问假的淘宝、拼多多，那你钱没了。
- 速度如何呢（一般般）-> so HTTP/2, HTTP/3
  - 长连接
    - HTTP/1.0不支持长连接，每一个请求都需要建立断开连接，累死了。HTTP/1.1提出长连接keep-alive，会好一些。
  - 对头阻塞（跟堵车一样）
    - 顺序发送的请求序列中的一个请求因为某原因被阻塞时，后面排队的所有请求也一同被阻塞了，会招致客户端一直请求不到数据。
  - 管道网络传输（HTTP/1.1有这个功能，但现实中没使用，我们认为他不具有好了）
    - 一个TCP连接中，客户端可以发起多个请求，只要第一个请求发出去了，不等其回来，就发第二个请求出去。但是**服务器必须按照接收请求的顺序发送对这些管道化请求的响应**。所以，**HTTP/1.1管道解决了请求的队头阻塞，但是没有解决响应的队头阻塞**。

#### HTTPS

![picture 18](../images/d38ff15738c9804253680ea3797dd335e4ff90262e6b3ad5486eb588fafa4c71.png){width=80%}

HTTPS在HTTP和TCP层之间添加`SSL/TLS`协议，解决了HTTP的不安全：**信息加密**防止窃听，**校验机制**防止篡改，**身份证书**防止冒充

对称加密：发送方和接收方用同样的规则（钥匙）对数据进行加密和解密。（直到加密规则就破解了）
非对称加密：用两个秘钥进行加密和解密，公开密钥所有人都知道，私有密钥仅仅持有方才有，私钥放在服务器中，数据经过公钥加密就只能被私钥解密，数据经过私钥加密就只能被公钥解密

## 三、TCP

### TCP基础

为什么需要TCP协议？
IP层不可靠，它不保证网络包的按序交付、数据完整性。
TCP提供可靠数据传输服务，确保接收端收到的网络包是无损坏、按序的、非冗余的。

TCP和UDP的**区别**：

1. 连接：TCP面向连接，UDP无需连接，即刻传输数据。
2. 服务对象：TCP是一对一，即连接只有两个端点。UDP支持一对一、**一对多、多对多**的通信。
3. 可靠性：
   1. TCP是可靠传输，数据可以无差错、不丢失、不重复、按序到达。
   2. UDP是尽最大努力交付，不保证可靠传输。（也可以基于QUIC协议整个可靠的UDP传输）
4. 拥塞控制、流量控制：
   1. TCP有拥塞控制和流量控制机制，保证数据传输的安全性。
   2. UDP没有，即使网络非常拥堵，也不影响UDP的发送速率。
5. 首部开销：
   1. TCP首部较⻓，在没有使用选项字段时是20字节
   2. UDP固定为8字节；简单的一批
      1. ![picture 10](../images/3aeddab71bc919933438243f8c22b20eb7e45f31a1a4b51b3dbe8863cccd1d43.png)
   3. 由于UDP头部长度固定，所以没有“首部长度”字段，而TCP需要。
6. 传输方式：
   1. TCP是**流式传输**（面向**字节流**），没有数据边界，但保证顺序和可靠。
   2. UDP是**一个包一个包**的发送（面向**数据报**），有数据边界，但可能会丢包和乱序。
      1. UDP存在数据边界，意味着read调用次数==write调用次数；
7. 分片不同：
   1. TCP的数据大小如果大于MSS大小，则会在传输层进行分片，目标主机收到后，也同样在传输层组装TCP数据包，如果中途丢失了一个分片，只需要传输丢失的这个分片。
   2. UDP的数据大小如果大于MTU大小，则会在IP层进行分片，目标主机收到后，在IP层组装完数据，接着再传给传输层。
8. 应用场景
   1. TCP: FTP文件传输, HTTP/HTTPS
   2. UDP: 包总量较少的通信(DNS, SNMP), 音视频，广播。

---

**讲解TCP报文头部格式**：
![picture 4](../images/ebdb15398a1f3cc979bb49063cfd987852f1ebf37b622f0920291a8411d9bd70.png){width=80%}

- 序列号：用于**解决网络包乱序**问题。在建立连接时由计算机生成的随机数作为其初始值，通过SYN包传给接收端主机，每发送一次数据，就累加一次该数据字节数的大小。
- 确认应答号/序列：用于**解决丢包问题**。指下一次期望收到的数据的序列号，发送端收到这个确认应答以后**可以认为在这个序号 以前的数据都已经被正常接收**。
- 控制位：
  - ACK: ACK=1时，**确认应答号字段**生效。TCP规定除了最初建立连接时的SYN包之外，该位均应设置为1.
  - RST: 为1表示TCP连接中出现异常必须强制断开连接
  - SYN: 为1表示希望建立连接，在**序列号字段**设定初始序列号。
  - FIN: 为1表示紧后不会再发送数据，希望断开链接。

---

**三次握手建立连接**：所谓连接，只是双方计算机内维护的一个状态机中的状态变化。
![picture 5](../images/d475e80daf89b4535421f44531cde1d66103f7257fabcf0bf6bfb59d814388cd.png){width=70%}
![picture 6](../images/f91309f4a756e298bfc70334f4b5bcb452ae341e58c9456021bf40c265006b48.png){width=70%}
**详图**：
![picture 11](../images/ae3c12a32ce60779b9636969ad9a0c1fca27770c566f00f14c7be3284a5f5c59.png)  

---

TCP连接就是用于保证可靠性和流量控制而维护的一些状态信息，包括**Socket**、**序列号**和**窗口大小**。
> 可以认为TCP连接三要素是：socket、序列号和窗口大小

**为什么TCP需要三次握手建立连接？**

1. RFC上指出，最主要原因是防止“历史连接”初始化了连接。
2. 同步双方初始序列号（一来一回才能确保双方的初始序列号实现同步）
   1. 四次握手当然也可以同步双方序列号，但中间两步(服务端到客户端的ACK和SYN)可以合并
   2. 两次握手则只保证了一方序列号的同步
3. 避免浪费资源
   1. ![picture 12](../images/39d76d8b38561770f9858b92dbcc44587e38667007f09c584b9798c061667cd3.png){width=80%}

![picture 13](../images/ed1937be670df442d52e8410ebc20b4984b8a262baf198eafa3fb1216c1bd9cf.png){width=80%}

为什么

## 四、IP

### IP address

IPv4: 32bit, max = 2^32 < 43亿, 4组8bit
IPv6: 128bit, 与ipv4不兼容，8组16bit
> 暂省ipv6知识，p697

如何解决ipv4不够用的问题？
**革新派**
1.ipv6
**守旧派**
2.无分类地址与子网划分: 充分利用ip地址
3.地址转换技术NAT: 将私有ip->公有IP

互联网诞生之初，ip看起来蛮多的，科学家设计了ip地址分类
![picture 19](../images/86c33e9eda184ec6af5078ddc57417142edd90f921d7afdc74dff7fb5a6f3644.png){width=80%}

- 某网络号对应最大主机数计算：$2^{主机号位数}-2$，主机号全0表示网络本身，主机号全1表示广播地址
  - > 广播地址会给同一链路中相连的所有主机发送数据包
  - > 广播分为本地广播(广播给本网络的所有主机，**不会穿过路由器**，192.168.0.0/24的广播地址为192.168.0.255)和直接广播（在不同网络之间的广播，192.168.0.0/24向192.168.0.255/24发送数据包时，路由器会将其转发给192.168.0.1/24，从而.1网络下所有主机都可收到）（不常用）
- D类E类地址没有主机号，不可用于主机ip；D类用于多播
  - > 多播用于将数据包发送给特定组内的所有主机。由于广播不会穿过路由器，所以可以采用可以穿透路由的组播给其他网段发送同样的包。组播的28bit为组编号

ip分类的缺点：

1. 同一个网络/网段下无法组织**层次**（同一公司想要按部门划分层次） -> 子网划分
2. 不能很好地与现实网络匹配，C类地址就254个，不够用，B类6万多个又太多了，浪费。 -> CIDR

**子网划分**：通过**子网掩码**将主机地址划分为子网网络地址和子网主机地址

**无分类地址CIDR**也分为网络号和主机号，表示为`a.b.c.d/x; x属于[0,32]`，很灵活。
> 分类地址中x=7,14,21, CIDR是分类地址的泛化表示

---

公有ip和私有ip：
![picture 20](../images/9672b635d1a2ac34d4e027a7836686a6354c773521ae32c668f23636bddbb35f.png){width=80%}
私有ip由组织内部人员管理

---

IP地址与路由控制：
路由控制表中记录着**网络地址**与下一跳ip地址(路由器)。
在发送IP包时，首先要确定IP包首部中的目标地址，再从路由控制表中找到与该地址具有相同**网络地址**的记录，根据该记录将IP包转发给相应的下一个路由器。如果路由控制表中存在多条相同网络地址的记录，就**选择相同位数最多的网络地址**，也就是最⻓匹配。

---

ip分片与重组：
每种数据链路的最大传输单元MTU不同，eg以太网MTU1500, FDDI数据链路MTU=4352。当ip包大于MTU，就会被分片。
> 分片后的IP包只会在目标主机处重组，中间的路由器可不会重组。

---

环回地址
其实127开头的都是环回地址...不止127.0.0.1奥
一般来说，IPV4下使用`127.0.0.1`作为loopback addr，IPV4使用`::1`。

### IP related protocol

#### dns

DNS: domain name -> ip addr
refer to section 1

#### ARP

ARP: IP -> mac
refer to section 1

#### DHCP

Dynamic Host Configuration Protocol
基于UDP广播； 应用层协议
![picture 21](../images/dbed3a1a55f355505d52fa34cac1f1fcdfe2ff8d3824b8de5d4783be6d68b9d6.png)  

如果DHCP服务器和客户端不在一个局域网，路由器又不转发广播数据博，怎么进行UDP广播呢？
-> **DHCP中继代理**诞生，实现一个DHCP服务器统一管理不同网段的ip地址的分配
![picture 22](../images/31d43ffc962a3a9b0c5f3f68bde3b1c5c987797c30cb705eaff6c40efb5526c0.png)  

#### NAT/NAPT

抢救IPv4两大手段：无分类编址子网划分 && NAT

Network Address (Port) Translation
纯粹(愚蠢)的NAT：NAT路由器将一个私有IP映射到一个公有IP，没卵用。
改进版NAPT: NAT路由器将多个私有IP及其端口映射到一个公有IP。
![picture 24](../images/b1e8a6309d576a0765966ce2a537582c814ff422a8384f8491268a7e57218a1a.png){width=80%}

NAT最大的缺点：
公网主机无法主动与内网主机建立联系，因为转换变中还没有映射记录。
so **NAT穿透技术**

![picture 23](../images/7625686289a948d73d853542050ffe8f8d3a539fecef217d13e760272bec8293.png){width=80%}

#### ICMP/ping/traceroute

虽然ICMP和IP都是网络层协议，但ICMP是基于IP的（层内关系）

Internet Control Message Protocol
互联网控制报文协议

![picture 25](../images/e2faf9bba0eb33c9f7d297f50890b8c845b2a8c011a4a8540df82acb7e556596.png){width=70%}
> 目标不可达：又可分为：网络不可达、主机不可达、协议不可达、端口不可达、**需要分片但设置了不分片(traceroute)**
> 原点抑制：为了缓和网络拥堵问题
> 重定向消息：路由器发现发送端主机没使用最优路径发送数据，返回该消息包含了最合适的路径
> 超时：**当IP头部的TTL字段(time to live)减为0(traceroute)**(每路过一个路由器-1)，丢弃该ip包，路由器返回一个超时消息。

ICMP工作在网络层，封装在IP数据包内
![picture 4](../images/7df0409c3058cc3700683e19af534832a3c7c3f4d5c21bbef87e2e8c3eb2f50b.png){width=70%}

**ping**--基于查询报文类型 （**应用层**命令）
man ping: send ICMP ECHO_REQUEST to network hosts
ping基于ICMP**回送请求echo request**和(8类型)ICMP**回送应答echo reply**(0类型)这两种**查询**报文，如果可以返回ICMP echo reply，说明发送端主机(host)可以到达接收端主机。

> 翻墙后依然ping不通google的原因大概是：代理软件只代理HTTP等应用层协议，而ping是ICMP网络层协议，故而ICMP无法被代理软件代理。

ping的详细流程：

![picture 5](../images/3b588df5eb45ec8be1fb57a366b28b2dcb5c7b2f3eb91756365a6ee6d8ba91a3.png){width=80%}
> 设置**序号**是为了区分ping所发送的多个数据包，ping在发送echo request时会在报文数据本分插入发送时间戳，收到echo reply之后用当前时间戳减一手就知道**RTT**往返时间了。

ping与TCP发数据的区别：
![picture 6](../images/74e465883cf0840cc3dce3dd5bd612ec8a56c760bca5b066accf27b8f444aa23.png){width=80%}
> socket中SOCK_STREAM是TCP，工作在传输层，SOCK_RAW是原始套接字，工作在网络层，构成ICMP的数据。
> 所以本质上，ping和普通程序发消息在流程上没啥区别。

ping 127.0.0.1会发生什么：
![picture 8](../images/f16309427ee5fb1cc7bbcd434e521f0799c4b1199d8831e8c14e5cfbfcf27a5a.png){width=70%}

![picture 7](../images/f6c33bdaf53a6d07ccfdd3033ce0144ffb59de20e839091bfbc1fea83dbc0d14.png){width=80%}

---

ping 本机ip又会发生什么：
ping 本机ip与ping 环回地址一样，都会走“假网卡”（`ifconfig`中的`lo`本地环回接口）
即二者一样。

---

`localhost` is a **domain name**, will be parsed to IP address `127.0.0.1`, can be modified by `vim /etc/hosts`
`0.0.0.0`表示**本机的所有IPv4地址**。(用于socket服务端的listen ip)

```c
/* Address to accept any incoming messages. */ 
#define INADDR_ANY ((unsigned long int) 0x00000000) /* 0.0.0.0   */
```

![picture 9](../images/df1ba68b49b13edefcb31753888e29e910c4dd35d3c13389dcf380201a6c1696.png)  

---

**traceroute**--基于差错报文类型
man: print the route packets trace to network host
> windows中叫做tracert

原理：**故意设置特殊的TTL**来追踪去往目的地时所经过的路由器。
specifically, 将IP包的TTL生存期限从1开始按顺序递增，发送**UDP包**，强制接收**ICMP超时**消息。
> 当然有的路由器就不会返回这个ICMP，所以对于有的公网地址，是看不到中间经过的路由的。dont know why.

最后，当差错报文类型是**端口不可达**时，说明发送方发出的UDP包到达了目的主机。（traceroute发送UDP包时会填一个不可能的目的端口号(一般认为不会使用的)）

---

traceroute还有一个作用：
原理：**故意设置不分片**，来确定路径的MTU
> 以太网的数据链路上的MTU通常是1500字节，但是非以太网的MTU值就不一样了，所以我们要知道MTU的大小，从而控制发送的包大小

specifically, 发送端主机发送IP包时将IP首部的**分片禁止标志位设为1**，途中的路由器便不会对大数据包分片，会直接将其丢弃，然后返回一个**ICMP目标不可达消息**（包含**数据链路的MTU**）。该目标不可达消息就是：**需要进行分片但设置了不分片**。

`traceroute -F host`: -F; --dont-fragment

#### IGMP

Internet Group Managemant Protocol
首先，IGMP和ICMP没有任何关系。
前面说D类ip可以组播，那么如何管理一组？因特网组管理协议上线。

IGMP工作在**主机**(组播成员)和**最后一跳路由器**之间。
IGMP报文向路由器申请加入和退出组播组，默认情况下路由器是不会转发组播包到连接中的主机；主机申请加入到组播组时，路由器就会记录IGMP路由器表，路由器后续就会转发组播包到对应的主机了。
详细见p714，暂略。

## 二、物理层

1. 通信双方按**交互方式**分类：(**信号传输**有哪几种方式)
   1. 单工通信：又称为单向通信，即只能有一个方向的通信而没有反方向的交互。例：无线电广播，电视广播
   2. 半双工通信：又称为双向交替通信，即通信的双方都可以发送信息，但不能双方同时发送（当然也就不能同时接受）
   3. 全双工通信：又称为双向同时通信，即通信的双方可以同时发送和接受信息。
2. Some Conception
   1. 信道：信号的传输媒介。分为模拟信道和数字信道
   2. 码元传输速率（波特率）：单位时间传输的码元（脉冲）个数；
   3. 信息传输速率（比特率）：单位时间传输的比特数（二进制码元个数）；
   4. 比特率=波特率*1码元携带的比特数
   5. 奈氏准则：理想低通（没有噪声、带宽有限）的信道中，极限**码元**传输速率为2W波特。
   6. 香农定理：带宽有限、有噪声时信道的极限数据传输速率为Wlog2(1+S/N)
3. 数字数据编码成数字信号：归零编码、非归零、反向非归零、曼彻斯特、差分曼彻斯特

## 三、数据链路层

1. **透明传输**：由于使用特定的字符来表示帧的开始和结束，所以传输的内容中不能出现和帧定界符相同的字符，但这显然是不可能的，为了解决这个办法，就可以在内容中和帧定界符一样的字符前边加上规定好的**转义字符**，这种方法称为**字符填充**或者是**字节填充**。
2. 流量控制：
   1. 停止-等待协议：发送一帧就要应答一帧，必须等待应答发送方才能继续发送。
   2. 滑动窗口流量控制：发送方维持一组连续的允许发送的帧的序号，叫发送窗口。接收方也维持接受窗口。由接收方对发送方进行流量控制。

3. 滑动窗口：
   1. 停等协议：发1收1（窗口尺寸）；逐个确认、逐个接收
   2. GBN后退N帧协议：发[1, 2^n - 1]，收1；累计确认，逐个接收
   3. SR选择重传协议：发=收=2^(n-1)；逐个确认，可乱序接收
4. 介质访问控制
   1. 信道划分介质访问控制：频分复用（并行）、时分复用（并发）、波分复用（光的频分复用）、码分复用（信道复用技术，为了提升传输能力和资源利用率）
   2. 随机访问介质访问控制：ALOHA、CSMA（先听再发）、CSMA/CD、CSMA/CA（CA是碰撞避免）
      1. CSMA/CD（载波监听多点接入/碰撞检测协议）：（CD是碰撞检测；先听再发、边发边听、冲突停发、随机重发)
      2. CSMA/CA（载波监听多点接入/碰撞避免技术） Carrier Sense Multiple Access with Collision Avoidance

## 四、重点

1. 有哪些私有（保留）地址？
 A类：10.0.0.0 - 10.255.255.255；B类：172.16.0.0 - 172.31.255.255；C类：192.168.0.0 - 192.168.255.255

2. ![图 1](../images/fb10b0e8b7e5a9ab8c239908223d4a6b42362a81be7ea8e9a9533ef60489f3de.png)  

3. ipv4和ipv6的区别
    ipv4是用32bit来表示的,通常分成4段8位序列，用10进制来表示每一段(范围就是0到255)以“.”分隔，而ipv6使用128bit表示,用十六进制来表示的，也按照8位分割，以16进制来记录每一段,以“：”分隔。
4. TCP（Transmission Control Protocol）和UDP（User Datagram数据报 Protocol）是OSI模型中的运输层中的协议。
    - TCP**面向连接**，UDP**面向非连接**；即发送数据前不需要建立链接
    - TCP提供**稳定可靠**的服务（数据传输），UDP无法保证，可能丢包
    - TCP面向**字节流**，UDP面向**报文**
    - TCP数据传输**慢**，UDP数据传输**快**
    - TCP适合传输文件、发送文件；UDP适合语音通话、视屏直播；

5. TCP中的流量控制和拥塞控制
    注：tcp协议如何保证传输的可靠性
    **流量控制**主要针对的是端到端传输中控制流量大小并保证传输可靠性（未收到ack就不滑动）。流量控制往往  是指**点对点**通信量的控制，所要做的是抑制发送端发送数据的速率。
    **拥塞控制**主要是一个**全局性过程**，涉及到所有主机，路由器，以及与降低网络传输性能有关的所有因素。防  止过多的数据注入到网络中。如果有发生丢包则通过拥塞控制减小窗口，确定出合适(==慢启动 拥塞避免 快重传 快恢复==)的拥塞窗口（增性加乘性减）。
    1. 慢启动：不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小;
    2. 拥塞避免：拥塞避免算法让拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍，这样拥塞窗口按线性规律缓慢增长。
    3. 快重传：快重传要求接收方在收到一个 失序的报文段 后就立即发出 重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。
    4. 快恢复：快重传配合使用的还有快恢复算法，当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半，但是接下去并不执行慢开始算法：因为如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将cwnd设置为ssthresh的大小，然后执行拥塞避免算法。
![图 6](../images/ef9e426eafa483023fd78366ab6d9b3c45258cb15462abd4821e86673fd37de8.jpg)  

1. DHCP（Dynamic Host Configuration Protocol，动态主机配置协议）应用层协议；通常被应用在大型的局域网络环境中，主要作用是集中的管理、分配IP地址，使网络环境中的主机动态的获得IP地址，能够提升地址的使用率。DHCP协议采用客户端/服务器模型。
![图 8](../images/3dcf0d51796942146ef20a05055e9780d1f29e3cc8d6b69fe458893f45f5fe35.png)

## other

1. 计网按分布范围分类：广域网WAN(Wide Area Network)、城域网MAN 5-50km（Metropolitan）、局域网 <1km LAN（Local）、个人区域网PAN <10m（Personal）
2. 传输方式按交换技术分类：（有哪些交换技术）
   - 电路交换网络：通过电路交换机建立一条专用的数据通信路径，通信过程中独占。
       - 优点：传输时延小、没有冲突、实时性强；
       - 缺点：独占式信道利用率低、建立连接时间长、灵活性差。
   - 分组交换网络：让连接到通讯电路的计算机将所要发送的数据分成多个数据包，并按找一定顺序排列后分别发送。(TCP/IP)
      - 优点：无需建立连接、信道利用率高、简化了存储管理、加速了传输；共享线路
      - 缺点：存在发送时延、可能会存在分组失序、丢失、重复。
3. 传输方式按有无连接分类：
   - 面向有连接(ATM，帧中继，TCP等，在通信传输之前，先打开一个连接，关闭无法发送数据)：在通信传输前后，专门进行建立和断开连接的处理，没有连接则无法通信，避免发送无谓的数据。
   - 面向无连接(以太网，IP，UDP等协议，无需确认对端是否存在，发送端可随时发送数据。)：接受端需要确定是否收到了数据；因为不需要建立连接，传输速度快。
4. 传输方式按接收端数量分类：
   - 单播(Unicast)：一对一通信。如早期固定电话。
   - 广播(Broadcast)：一对所有通信。一台主机与广播范围(广播域)下其他所有主机通信，如电视播放。
   - 多播(Multicast)：一对多通信。与广播类似，限定某一组主机作为接收端，e.g., 视频会议。
   - 任播(Anycast)：一对特定一通信。指对接收端有选择的通信，与多播相似，选择一组主机中最优目标主机发送，选中主机返回单播信号，随后进行单播，如DNS根域名解析系统。
5. 性能指标
   1. 带宽Bandwidth：数字信道所能传送的“最高数据传输速率”。
   2. 时延Delay：发送时延+传播时延+处理时延+排队时延。
   3. 时延带宽积：以比特为单位的链路长度，= 传播时延 * 信道带宽。
6. 协议：计算机与计算机之间通过网络实现通信时事先达成的一种约定或规范；ISO制定了一个国际标准OSI; IETF制定了一个业界标准，i.e., TCP/IP; 上下层之间交互遵循的约定叫接口，同层之间交互遵循的约定叫做协议。
7. 网络设备

- **网卡(NIC)/网络适配器**: network interface card/网络接口卡：将数字信号(由一系列01组成的网络包)转换为电信号或光信号，并通过网线或光纤发送出去，到达下一个集线器、路由器等设备
- **中继器(repeater)**: **物理层**面上延长网络的设备；半双工（碰撞现象）
  - 多口中继器又名中继集线器，简称**集线器**(repeater hub): ==无脑将电信号广播到所有端口==，不安全，浪费资源；
  - RJ-45 + PHY(MAU) + 中继电路
  - 广播，一次也只能转发一个包（否则碰撞）
- > 由于集线器会广播到所有端口，浪费资源且不安全。所以考虑单播，所以集线器 + MAC地址表。
- 网桥(bridge)/**二层交换机**: **数据链路层**面上连接两个网络的设备/连接不同终端；全双工
  - 多口网桥又名交换集线器，简称**交换机(switching hub)**: 高级集线器，只发送给目标MAC的端口，维持MAC地址表（MAC->物理端口）；
  - RJ-45 + PHY(MAU) + MAC模块 + 缓冲区 + 交换电路
  - (切记**交换机MAC模块不具有MAC地址**，直接接受所有的包存放到缓冲区，然后由交换电路根据MAC地址表进行包转发到相应端口)
  - 一次可以转发多个包
  - 交换机只是转发包，不会成为发送方或接收方
  - 交换机在地址表中匹配完全一致的MAC
  - 交换机中对 MAC 地址表的维护是包转发操作中的一个步骤
- > 由于交换机不具备独立MAC，当连接另一个交换机的时候需要为另一个交换机上连接的所有电脑的mac都做一个映射，映射表太大了，所以考虑给交换机 + MAC，
- **路由器(router)/三层交换机/网关(gateway)**: **网络层**面上连接两个网络的设备，每一个端口都有独立MAC
  - 端口模块(eg ADSL, FTTH, 无线局域网, 以太网) + 包转发模块(路由表)
  - 路由器的各个端口都具有MAC地址和IP地址
  - 路由器会作为发送方从相应端口发送
  - 路由器在地址表中仅匹配网络号部分，忽略主机号
  - 路由器中对路由表的维护是与包转发操作相互独立的
  - 补充：
  - 光猫/数字调制解调器/翻译(modem): 将光纤的光信号转换为网络信号，然后路由器才能联网
  - 光猫一定有光纤输入接口吧，然后现在的光猫很多有路由功能，但据说比较菜
  - 路由器wan口接光猫，lan口接电脑，还有wifi