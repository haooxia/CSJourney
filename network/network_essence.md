# 计算机网络笔记

- [计算机网络笔记](#计算机网络笔记)
  - [一、基础](#一基础)
    - [分层](#分层)
    - [输入URL到页面展示发生了什么](#输入url到页面展示发生了什么)
      - [概括](#概括)
      - [详解DNS解析](#详解dns解析)
      - [详解ARP地址解析 (MAC)](#详解arp地址解析-mac)
      - [网卡 交换机 路由器 服务器](#网卡-交换机-路由器-服务器)
        - [网卡](#网卡)
        - [交换机](#交换机)
        - [路由器](#路由器)
        - [服务器](#服务器)
  - [二、HTTP](#二http)
    - [常见状态码及字段](#常见状态码及字段)
    - [GET vs. POST](#get-vs-post)
    - [HTTP缓存：强缓存 \& 协商缓存](#http缓存强缓存--协商缓存)
    - [HTTP1.0 vs HTTP1.1](#http10-vs-http11)
    - [HTTP1.1 vs HTTP2.0](#http11-vs-http20)
    - [HTTP特性](#http特性)
    - [HTTPS](#https)
    - [HTTPS vs. HTTP](#https-vs-http)
    - [Cookie vs. Session](#cookie-vs-session)
  - [三、TCP](#三tcp)
    - [TCP vs. UDP](#tcp-vs-udp)
      - [为什么DNS基于UDP](#为什么dns基于udp)
    - [TCP头部](#tcp头部)
    - [三次握手 四次挥手](#三次握手-四次挥手)
      - [三次握手](#三次握手)
        - [为什么不是两次握手？](#为什么不是两次握手)
        - [为什么不是四次握手？](#为什么不是四次握手)
      - [四次挥手](#四次挥手)
        - [为什么是四次挥手？](#为什么是四次挥手)
        - [为什么TIME\_WAIT等待时间为2MSL](#为什么time_wait等待时间为2msl)
  - [四、IP](#四ip)
    - [IP address](#ip-address)
    - [IP related protocol](#ip-related-protocol)
      - [dns](#dns)
      - [ARP](#arp)
      - [DHCP](#dhcp)
      - [NAT/NAPT](#natnapt)
      - [ICMP/ping/traceroute](#icmppingtraceroute)
      - [IGMP](#igmp)
  - [二、物理层](#二物理层)
  - [三、数据链路层](#三数据链路层)
  - [四、重点](#四重点)
  - [网络设备](#网络设备)


## 一、基础

### 分层

OSI七层结构
TCP/IP四层参考模型：应用层（上三层），传输层，网络层，网络接口层（下两层）

![picture 0](../images/38d98be16bd0cfa551b6469ba2891c1a5180c4170d899cb2dc264cd3790ff7b1.png){width=70%}  

七层协议详解（可以直接忽略表示层、会话层，然后合并下两层）

1. **应用层Application Layer** ：为**特定应用程序**提供数据传输服务，e.g., HTTP, FTP, Telnet, DNS, SMTP, SSH等。数据单位为==报文==。
    1. 应用层工作在os的用户态，传输层及以下工作在内核态。
2. 表示层 ：**设备固有数据格式和网络标准数据格式的转换**（压缩、加密和解密），接受不同形式的信息，文字图像声音等。
3. 会话层 ：通信管理，负责**建立和断开通信连接**；
4. **传输层Transport Layer** ：负责不同主机中两个**进程**之间的通信（通过**端口**）。
5. **网络层Internet Layer** ：负责两台**主机**之间的通信，也叫点对点通信(end-to-end)。将数据传输到目标地址，目标地址可以是多个网络通过路由器连接的而成的某一个地址，负责**寻址和路由选择**。
6. **数据链路层(MAC层)** ：负责物理层面上的**直连**的设备之间的通信。网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成==帧==。PPP Ethernet
    1. 网络层是source address -> target address，数据链路层仅负责其中的一个个区间内的通信。
7. **物理层** ：负责数据的物理传输，包括物理接口、传输介质等


MAC地址：网卡(NIC)设备出厂会烧一个唯一MAC，其层次性对寻址没用，可以不算有层次性；MAC寻址参考地址转发表；
IP地址：网络号+主机号；具有层次性；IP寻址参考路由控制表；

![picture 2](../images/546a3eb0a30aacda3b1e23cbb4a26277d6b5805460445b2ebbae5bba1ebd1ddc.png){width=80%}

---

### 输入URL到页面展示发生了什么

> URL是web服务器中的一个文件资源
> UTL = http(s): + // + web服务器 + / + 目录名 + / +文件名

#### 概括

1. 浏览器接收用户请求，**先检查浏览器缓存**中是否缓存该资源，如有直接返回，如无进入下一步网络请求。
2. **网络请求前，进行DNS解析**，以获取请求域名domain的IP地址。**DNS解析时会按照本地浏览器缓存 -> 操作系统缓存 -> 本地Hosts文件 -> 路由器缓存/IPS互联网服务商DNS缓存 -> 本地DNS服务器 -> 根DNS服务器 -> 顶级域名服务器 -> 权威域名服务器的顺序查询域名对应IP，直到找到为止**。
3. **浏览器和服务器通过三次握手建立TCP连接（由os网络协议栈调用socket完成）**。连接建立后，浏览器端会构建请求行、消息头和消息体，向服务器发送请求报文。
4. 服务器接收到**请求**信息（解析请求，根据请求路径和参数，调用相应的后端逻辑(eg 数据库查询、文件读取等)），生成**响应数据**。
5. 浏览器解析响应头。先根据状态码决定后续操作（如状态码为301、302，会重定向到新地址）；再根据Content-Type决定如何处理响应体（若是二进制字节流类型，提交给下载管理器；若是HTML类型，进入**页面渲染流程**）。
6. 浏览器解析HTML文件，构建DOM树，解析CSS文件，执行JS代码，最终完成页面渲染和展示。

#### 详解DNS解析

DNS(Domain Name System)服务器专门保存了web服务器域名与其ip之间的映射，是一种服务器。
> 域名用·分隔，越靠右层级越高(老外总喜欢反着来)
> DNS基于UDP

实际上www.google.com完整形式是www.google.com.; 域名层级关系为:

1. **根域名**DNS服务器(.): Root DNS Servers
2. **顶级域名**DNS服务器(.com): Top-Level Domain(TLD) Servers
3. **权威域名**DNS服务器(google.com): Authoritative DNS Servers
4. **递归域名**服务器(**本地域名**服务器)：Recursive DNS Servers，负责向其他DNS服务器查询映射信息，给到用户。

> 根域的DNS服务器信息存在互联网的所有DNS服务器中。故而所有DNS服务器都可找到根域DNS服务器，一路向下顺藤摸瓜就找到了目标DNS服务器。

迭代查询方式：
![picture 3](../images/4409049a453e8d1247bd99cb6b4d457731b42904896f29fa9c5c170a5ed72c65.png){width=80%}

> 以上为迭代查询，还有一种递归查询（不常用吧）
> 本地DNS服务器就是递归DNS服务器，一般可能在运营商那。
> DNS解析中**缓存查询**：先查询浏览器缓存 -> 查询操作系统缓存 -> 查询Hosts文件 -> (路由器缓存、ISP缓存) -> 都没有才去问本地DNS服务器

<!-- #### 协议栈

通过DNS获取IP之后，就可以把HTTP传输工作交给**操作系统中**的协议栈了。
![picture 3](../images/92c260712371e4d925336283e8a0b47f961907ac7bcfd17e7c6ef38fab85311f.png){width=60%}

- 应用程序调用socket来委托协议栈工作

协议栈中一步步来咯 -->

<!-- ##### 3.1 TCP

http基于tcp。

##### 3.2 IP

可是发给谁呢，TCP头部目前只有port，需要搞个目标主机的地址啊。ip来整远程定位吧。

老规矩，讲解IP报文头部格式：
![picture 8](../images/5f8286a1a030393169bcfa23ecf28c93649fd5fb79e7c7156ca18a2073f4335c.png){width=70%}

ok，现在网络报的报文为：
|IP头部|TCP头部|HTTP报文(HTTP头部+数据)|
|------|------|----------------------| -->

#### 详解ARP地址解析 (MAC)

ok，挺好的，ip帮我远程定位到**最终**目标地址了，可是好远啊，我下一站去哪儿呢？需要一个**两点传输**助手：MAC。

> 注意MAC功能属于IP层(arp)，不是网卡控制的奥。

老规矩，上MAC头部：
![picture 10](../images/8dfab644c4e9cd5276a096001a4ad9b09c3bdc97d6c20f9a1a7fde819fba7a7d.png){width=70%}

发送方MAC：从网卡读一下
接收方MAC：（有点复杂，交给ARP）

==ARP地址解析协议==：IP->MAC; `arp -a`
若同一个局域网中的主机A给B发数据，先查询**ARP缓存**(就几分钟...)中有无B的IP，若有，相应mac写入mac帧发送即可；
若无，发送**帧广播ARP请求分组**：目的MAC地址为FF-FF-FF-FF-FF-FF，目的ip也已知。主机B收到请求后，向A单播一个包含自己mac的ARP应答分组。

知道了目标ip对应的MAC之后，就确定了下一站地址（交换机内部维持一张mac->端口的映射表(此处的端口真的是交换机上的物理端口)）也即**以太网内的传输是基于mac的**。

> ARP请求/应答报文 = 发送端mac + 发送端IP + 目的端mac + 目的端ip

ok，现在网络报的报文为：
|MAC头部|IP头部|TCP头部|HTTP报文(HTTP头部+数据)|
|----|------|------|----------------------|

> question: why we need MAC addr? 

#### 网卡 交换机 路由器 服务器

##### 网卡

我们的网络包是一堆二进制数据，无法直接发给对方，需要将**数字信号转为电信号**，才能在网线上传输，即真正的传输。**网卡**要登场了。在网卡之前，还有**网卡驱动程序**。

首先，**网卡驱动**获取网络包之后，会将其**复制**到**网卡内的缓存区**中，接着会在其开头加上**报头**和**起始帧分界符**， 在末尾加上用于检测错误的**帧校验序列**。

==到此，真的是封装完毕了==！交给网卡转为电信号发出去了。

##### 交换机

交换机位于MAC层(**数据链路层**)，二层网络设备。**交换机的端口没有mac地址。**

网线上电信号来到交换机，将其转换为数字信号。根据FCS进行错误校验，若没问题，放到交换机缓冲区内。（无法判断mac所以没出错的话统统接受）

交换机内部维持着一张**mac地址表->端口之间的映射表**。据此，就可以知道要发给目标mac电脑要走哪个端口。如果映射表中没找到，只能转发到除了源端口以外的所有端口，非目标机自动丢弃。（目标机响应的时候可以记录下映射）

> 集线器hub是无脑将收到的电信号广播给所有出口。很呆，所以是一层网络设备(物理层)。接收方主机通过mac地址进行判断是不是发给自己的。
> 交换机是将收到电信号只发给**目标mac指定的电脑对应的出口**。有点聪明，定义到二层网络设备(数据链路层)。

##### 路由器

网络包经过交换机后到达路由器，将会转发给下一个路由器或目标设备。
路由器基于ip(网络层)，三层网络设备，**路由器的各个端口都具有MAC地址及IP地址**。
交换机基于以太网，二层网络设备，各个端口没有mac。由于路由器端口具有mac，故而可以成为以太网的发送方和接收方。各个端口的ip使其某种意义上和计算机内网卡一样。

路由器端口作为接收方收到以太网包后，根据**路由表**查询转发目标，再由相应的端口作为发送方将以太网包发出去。

Specifically，接收以太网包，开始类似于交换机，将电信号**转为数字信号**，然后进行**FCS校验**。此外，**检查头部的目的mac地址**是不是自己，如果是，放到路由器缓冲区中。不是，直接丢弃，交换机没这功能。

然后mac地址的使命结束（mac头部的作用就是将包送给下一个路由器），那么**去掉mac头部**，然后根据ip头部进行转发。

**如何转发ip包呢？**
![picture 12](../images/f20b24bf718d2d5b24c356027df2063085c7e583a8fbd95431651a7dfc9faf54.png){width=80%}
> `route -n`或者`netstat -r`查询路由表

1. 查询路由表判断转发目标。
   1. 路由匹配：根据目标ip查询路由表的目标地址列，将目标ip与每个条目的的子网掩码进行与操作，如匹配，将该路由器端口作为转发目标。如果没匹配的，选择默认路由`0.0.0.0`.
2. 路由器发送包（**仅修改mac头部(因为以太网内的两个设备传递依靠mac)，不动ip头部**）
   1. 根据路由表的网关列(gateway)判断对方的ip地址（**路由器不修改包内两端的ip奥**）。网关列显示了需要把数据包发送给哪个ip才能到达目标网段
      2. 如果目标网络在本地网段内，网关列可能显示0.0.0.0或空，表示直接可达。
      3. 如果网关列有个ip地址，说明还没到，这个ip是下一跳网关，数据包需要先到这个网关，然后再进行转发。
   2. 知道了ip之后，使用arp查到mac作为目标mac(路由器也有arp缓存)，本地mac使用路由器该端口的mac。**修改mac头部**之后将包转为电信号通过端口发送。
3. 如此经过多个路由器后，网络包到达最终网段。

![picture 13](../images/e7fb0a8562dc9e5db7d411c6dedf7f0c23538c1353024bde1dab52cb2bec6844.png)  

> 交换机转发过程中会修改mac，不修改ip，也会重新计算尾部fcs；我感觉头尾网卡负责的部分可能都需要修改，但我不确定:)

##### 服务器

网络包到达服务器后，先检查mac头部看看mac匹配否，匹配就收下。（要FCS校验吗？）然后看看ip头部的协议项，知道了上层是tcp协议，然后看看tcp头部，看看里面的序列号是不是想要的，是就放到缓存，返回一个ACK，不是则丢弃。此外，由于服务器的HTTP在监听80，如果tcp头部端口是80，服务器就把包发给http进程了。

HTTP进程看到这个请求是要访问一个页面，于是就把这个网页封装在HTTP响应报文里。响应报文也需要穿上相应的TCP、IP、MAC头部。完事儿后从网卡出发->交换机->路由器-> ... ->客户端那边的路由器->交换机->客户端->开始扒掉头部剩下http响应报文->交给浏览器渲染webPage，over！

最后，客户端要离开了，双方四次挥手断开连接（沟通一次真的挺累的。

## 二、HTTP

HTTP (HyperText Transfer Protocol)超文本传输协议
超文本：文字、图片、视频、超链接的混合体，HTML是常见的超文本，本身只是纯文字文件，但内部用很多标签定义了图片、视频等的链接，经过浏览器的解释，可以呈现一个有文字和画面的网页

> HTTP是一个应用层协议,通常基于TCP实现;TCP是传输层协议;而**Socket是对TCP/IP协议的抽象和封装**,提供了**编程接口**。在实际应用中,HTTP通常通过Socket API来使用TCP协议。

### 常见状态码及字段

HTTP报文：
请求行/状态行（方法 URL 版本） + 消息头（首部字段+字段值） + 消息体（数据）

常用字段

- Host字段：客户端发送请求时，用来指定服务器的域名
- Connection字段：客户端要求服务器是否使用TCP持久连接，以便其他请求复用
  - HTTP/1.1默认使用持久连接，1.0默认未开启，需要显式设置Connection: keep-alive
- Content-Length字段：服务器在返回数据时，使用Content-Length字段表明本次回应的数据长度
- Content-Type字段：服务器回应时，告诉客户端，本次数据是什么格式，比如html/png/json/pdf
- Content-Encoding字段：表示服务器返回的数据使用了什么压缩格式

![picture 2](../images/a7648d5bc32602b1fec77e874c499a36f16bf893e41b45e119f314533421245f.png){width=90%}

### GET vs. POST

1. 作用不同
   1. GET用于从服务端获取数据
   2. POST一般用来向服务器发送数据来创建或更新资源，通常用于提交表单数据或上传文件
2. 参数传递方式不同
   1. GET请求的参数一般写在URL中，不适合传输敏感数据；数据量较小，不超过2KB，且只接受ASCII字符
   2. POST请求参数一般放在请求体中，更加安全；理论上长度不受限；对于数据类型也没有限制
   3. > HTTP 协议没有 Body 和 URL 的⻓度限制，对 URL 限制的大多是浏览器和服务器的原因。
3. 缓存机制不同
   1. GET请求会被浏览器主动缓存，而POST一般不会，除非手动设置。
4. 时间消耗不同
   1. GET 产生一个 TCP 数据包；
   2. POST 产生两个 TCP 数据包。
      1. 对于 GET 方式的请求，浏览器会把 header 和 data 一并发送出去，服务器响应 200（返回数据）； 而对于 POST，浏览器先发送 Header，服务器响应 100 continue，浏览器再发送 data，服务器响 应 200 ok（返回数据）
5. 幂等：多次执行相同的操作，返回的结果相同
   1. RFC(Request for comments)规范如下（但程序员未必遵守...）：
      1. GET 方法就是安全且幂等的，因为它是「只读」操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。
      2. POST 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是不安全的，且多次提交数据 就会创建多个资源，所以不是幂等的。

### HTTP缓存：强缓存 & 协商缓存

对于一些重复性的HTTP请求，可以把这对「请求-响应」的数据都缓存在本地。
缓存的作用：

- 减少不必要的网络传输，节约带宽
- 更快的页面加载速度
- 减少服务器负载，避免服务器过载

HTTP缓存有两种实现方式：**强制缓存**和**协商缓存**。

- **强制缓存**：浏览器判断请求的目标资源是否有效命中强缓存，如果命中，则可以直接从内存中读取目标资源，无需与服务器做任何通讯，决定是否使用缓存的主动性在于浏览器这边。
  - 强制缓存在response header设置两个字段表示资源在客户端缓存的有效期：
    - 绝对时间Expires：存一个时间戳，然后之后使用本地时间戳判断，但有大问题：本地时间不准...遂expires废弃
  - 相对时间Cache-control：存缓存秒数
- **协商缓存**：通过服务端告知客户端是否可以使用本地缓存的资源，通过`304`状态码表示。(**很像乐观锁的版本号法了**)
  - 方式一：基于时间：`Last-modified` & `If-modified-since`：首先需要在服务器端读出文件修改时间赋给响应头的last-modified字段（并设置`Cache-control:no-cache`），然后再次请求该资源时，都会带上`If-Modified-Since(时间即为上面的Last-modified)`字段，然后服务端拿到这个时间并再次读取该资源的修改时间，对比二者来决定是读取缓存还是返回新的资源。
    - 缺点：
      - 文件内容本身不修改的情况下，依然有可能更新文件修改时间
      - 文件在极短时间内完成修改的时候（eg 几百ms），文件修改时间不会改变，因为文件修改时间记录最小单位是s
  - 方式二：基于标识，**优先级更高**：`Etag` & `If-None-Match`：将原先协商缓存的**比较时间戳的形式修改成了比较文件指纹**（服务器根据文件内容计算出的唯一**哈希值**然后返回给客户端），然后再次请求时将Etag值赋给请求头的`If-None-Match`，服务端拿到后比较两个指纹，如果一致，返回304(未修改)状态码和一个空的响应体。如不一致，返回文件+新Etag
    - 缺点
      - 计算和验证Etag耗费服务端开销；

> 有哈希值的文件设置强缓存即可。没有哈希值的文件（比如index.html）设置协商缓存
> 协商缓存这两个字段都需要配合强制缓存中 Cache-Control 字段来使用，**只有在未能命中强制缓存的时候，才能发起带有协商缓存字段的请求**。

### HTTP1.0 vs HTTP1.1

1. 长连接(底层socket默认60s)
   1. HTTP1.0默认为短连接，每次请求都需要建立一个TCP连接。
   2. HTTP1.1支持**长连接**，==每一个TCP连接上可以传送多个HTTP请求和响应==，默认开启Connection:Keep-Alive (该字段要求完成该HTTP请求后**不要断开HTTP请求使用的TCP连接**，然后下次发http请求时无需重新建立TCP连接（同时SSL的开销也可以避免了）)
2. 缓存
   1. HTTP1.0主要使用Expires/If-Modified-Since来做为缓存判断的标准
   2. HTTP1.1则引入了更多的缓存控制策略，例如Entity tag/If-None-Match缓存策略。
3. 管道化
   1. 支持**管道（pipeline）网络传输**，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出 去，可以减少整体的响应时间。

### HTTP1.1 vs HTTP2.0

1. 首部压缩
   1. HTTP1.1不支持header数据的压缩，HTTP/2.0使用HPACK算法(消除多个请求中重复的头部)对header的数据进行压缩，减少数据体积，加速传输。
2. 二进制分帧 & 二进制格式
   1. 在应用层(HTTP/2)和传输层(TCP)之间增加了一个**二进制分帧层**，将所有传输的信息分割为更小的消息和帧(frame)，并对它们采用**二进制格式编码**,更高效且错误率更低。
   2. HTTP/1.1是基于文本的,解析相对复杂且容易出错。
   3. 比如200用文本转二进制就是`'2','0','0'各自对应1字节`，而直接二进制编码的话状态码200用`10001000`一字节即可
3. 多路复用
   1. HTTP/1.1虽然支持长连接,但每个请求仍然要占用一个TCP连接,HTTP完成一个事务(请求与响应过程)后，才可处理下一个事务，容易造成**队头阻塞**。
   2. HTTP/2.0引入了多路复用技术,允许在同一个TCP连接上同时发送多个请求和响应。（多个Stream复用在一条TCP连接）
4. 服务器推送server push
   1. 在HTTP/2中，服务器可以对客户端的一个请求发送多个响应，**即服务器可以额外的向客户端推送资源，而无需客户端明确的请求**

### HTTP特性

- 简单、灵活、易于扩展
  - http在应用层，下层可以任意变化
    - HTTPS：在HTTP与TCP层之间增加了SSL/TLS安全传输层
    - HTTP/1.1和HTTP/2.0传输协议使用的是TCP协议，而到了 HTTP/3.0传输协议改用了UDP协议。
- **无状态**
  - 好处：服务器不会去记忆HTTP的状态，减轻负担。
  - 坏处：每个请求都是独立的，不依赖于之前的请求。虽然这简化了服务器的设计，但在需要保持会话状态时，需要借助Cookie、Session等技术
- **明文传输**
  - HTTP默认是明文传输的，数据在传输过程中不加密。这使得数据容易被窃听和篡改，安全性较低，so HTTPS (secure)
- 支持缓存
  - HTTP支持通过头字段（如Cache-Control、ETag等）实现客户端和代理服务器的缓存机制，提高访问速度和减少服务器负载。
- **不安全**
  - 窃听风险：**通信使用明文**（不加密），内容可能会被窃听。比如，账号信息容易泄漏，那你号没了。
  - 篡改风险：**无法证明报文的完整性**，所以有可能已遭篡改。比如，网⻚上植入垃圾广告，视觉污染，眼没了。
  - 冒充风险：**不验证通信方的身份**，因此有可能遭遇伪装。比如，访问假的淘宝、拼多多，那你钱没了。

### HTTPS

![picture 18](../images/d38ff15738c9804253680ea3797dd335e4ff90262e6b3ad5486eb588fafa4c71.png){width=80%}

HTTPS在HTTP和TCP层之间添加`SSL/TLS`协议，解决了HTTP的不安全：**信息加密**防止窃听，**校验机制**防止篡改，**身份证书**防止冒充

**对称加密**：发送方和接收方用同样的规则（钥匙）对数据进行加密和解密。（直到加密规则就破解了）
**非对称加密**：用两个秘钥进行加密和解密，公钥所有人都知道，私钥仅仅持有方才有，私钥放在服务器中；数据经过公钥加密就只能被私钥解密，公钥自己也无法破解；数据经过私钥加密就只能被公钥解密，私钥自己也无法解密，即加解密的过程并不对称

### HTTPS vs. HTTP

- HTTP是明文传输，而HTTPS通过在HTTP和TCP层之间加入了SSL\TLS安全协议，使得报文能够加密传输
- HTTP连接建立相对简单，TCP三次握手之后便可进行HTTP的报文传输。而HTTPS在TCP三次握手之后，还需进行SSL/TLS的握手过程，才可进入加密报文传输。
- HTTP的默认端口号是80，HTTPS是443
- HTTPS协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的

### Cookie vs. Session

> Cookie和Session不是应用层协议,是用于在HTTP这个应用层协议的基础上实现状态管理的机制。

它们分别是什么？

- Cookie和Session都用于**管理用户的状态和身份**, Cookie通过在客户端记录信息确定用户身份，Session通过在服务器端记录信息确定用户身份。
- Cookie是存储在**浏览器**中的小型文本文件，用于在用户和服务器之间传递数据。通常，服务器会将一个或多个Cookie发送到用户浏览器，然后浏览器将这些Cookie存储在本地。服务器在接收到来自客户端的请求之后，就能够通过分析**存放于请求头的Cookie**得到客户端特有的信息，从而动态生成与该客户端相对应的内容。(注：url中的get参数和request headers没什么关系)
- 客户端访问服务器的时候，服务器把客户端信息以某种形式**记录在服务器上**。这就是Session。Session主要用于维护用户登录状态、存储用户的临时数据和上下文信息等。

二者的区别：

- 存储位置：Cookie数据存储在用户的浏览器中，而Session数据存储在服务器上
- 数据容量：Cookie存储容量较小，一般为几KB。Session存储容量较大，通常没有固定限制，取决于服务器的配置和资源
- 安全性：由于Cookie存储在用户浏览器中，因此可以被用户读取和篡改。相比之下，Session数据存储在服务器上，更难被用户访问和修改
- 传输方式：Cookie在每次HTTP请求中都会被自动发送到服务器，而SessionID通常通过Cookie或URL参数传递

## 三、TCP

为什么需要TCP协议？
IP层不可靠，它不保证网络包的按序交付、数据完整性。
TCP提供可靠数据传输服务，确保接收端收到的网络包是无损坏、按序的、非冗余的。

### TCP vs. UDP

TCP和UDP的**区别**：

- 概念
  - TCP（传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议
  - UDP（用户数据报协议）为应用程序提供了一种无需建立连接就可以发送封装的IP数据包的方法。
- 特点
  - TCP：面向连接，传输可靠，传输形式为**字节流**，传输效率慢，所需资源多。
  - UDP：无连接、传输不可靠、传输形式为**数据报文段**，传输效率快，所需资源少。
- 区别
  - 是否面向连接
  - 是否是**可靠**传输：TCP是可靠的传输服务，在传递数据之前，会有三次握手来建立连接；在数据传递时，有确认、窗口、重传、拥塞控制机制。UDP是不可靠传输(尽最大努力交付)，数据传递不需要给出任何确认，且不保证数据不丢失及到达顺序。（也可以基于QUIC协议整个可靠的UDP传输）
  - 是否有**状态**：TCP传输是有状态的，它会去记录自己发送消息的状态比如消息是否发送了、是否被接收了等等，而UDP是无状态的。
  - **传输形式**: TCP是**面向字节流**的（流式传输，没有数据边界，但保证顺序和可靠），UDP是面向报文的（一个包一个包地发送，有数据边界，但可能丢包或乱序）。
    - UDP存在数据边界，意味着read调用次数==write调用次数；
  - 传输**效率**:由于TCP传输的时候多了连接、确认重传等机制，所以TCP的传输效率要比UDP低。
  - **首部开销**:TCP首部开销(20 ~ 60字节)比UDP首部开销(8字节)要大。
  - 是否提供**广播或多播**服务: TCP只支持点对点通信UDP支持一对一、一对多、多对一、多对多。
- 应用场景
   1. TCP: 常用于要求通信数据可靠场景（如网⻚浏览(HTTP/HTTPS)、文件传输(FTP)、邮件传输、远程登录(SSH)、数据库操作等）
   2. UDP: 常用于要求通信速度高场景（如域名转换、视频直播、实时游戏等），广播。

#### 为什么DNS基于UDP

1. 速度快
2. 大多数DNS查询和相应数据包都很小
3. DNS查询时一次性的，无需维护连接状态（UDP无连接）
4. 减少服务器负载（无需连接嘛、请求响应也比较简单、易于负载均衡

### TCP头部

**讲解TCP报文头部格式**：
![picture 4](../images/ebdb15398a1f3cc979bb49063cfd987852f1ebf37b622f0920291a8411d9bd70.png){width=80%}

- **序列号seq**：用于**解决网络包乱序**问题。在建立连接时由计算机生成的随机数作为其初始值，通过SYN包传给接收端主机，每发送一次数据，就累加一次该数据字节数的大小。
- **确认应答号ack**：用于**解决丢包问题**。指下一次期望收到的数据的序列号，发送端收到这个确认应答以后**可以认为在这个序号 以前的数据都已经被正常接收**。
- 控制位：
  - ACK: ACK=1时，**确认应答号字段**生效。TCP规定除了最初建立连接时的SYN包之外，该位均应设置为1.
  - RST: 为1表示TCP连接中出现异常必须强制断开连接
  - SYN: 为1表示希望建立连接，在**序列号字段**设定初始序列号。
  - FIN: 为1表示紧后不会再发送数据，希望断开链接。

### 三次握手 四次挥手

#### 三次握手

**三次握手建立连接**：==所谓连接，只是双方计算机内维护的一个状态机中的状态变化。==

三次握手的过程如下：

0. 首先是客户端和服务端都处于CLOSED状态；先是服务端主动监听某个端口，处理LISTEN状态
1. 客户端主动发起连接(发送SYN报文、初始化序列号ISN（seq=x）)，然后客户端进入SYN_SEND状态，等待服务器确认。
2. 服务端收到客户端发起的链接，发送ACK确认客户端的SYN报文(ack=x+1），同时发出一个SYN报文，带上自己的初始化序列号（seq=y），然后服务端进入SYN_RECV状态。
3. 客户端接收到服务端的SYN，ACK报文后，发送ACK确认服务端的SYN报文（ACK=y+1），然后处于ESTABLISHED状态，因为客户端一发一收成功了。
4. 服务端收到ACK后，也处于ESTABLISHED状态，因为它也一发一收了。

> 所以**三次握手是为了保证二者都具备收发功能**：即第一次握手服务器知道客户端能发，第二次握手客户端知道服务器能发能手，第三次握手服务器知道客户端能收
> `netstat -napt`: 查询tcp连接状态

![picture 5](../images/d475e80daf89b4535421f44531cde1d66103f7257fabcf0bf6bfb59d814388cd.png){width=60%}

TCP连接就是用于保证可靠性和流量控制而维护的一些状态信息，包括**Socket**、**序列号**和**窗口大小**。
> 可以认为TCP连接三要素是：socket、序列号和窗口大小

##### 为什么不是两次握手？

1. **确保双向通信的可靠性**。三次握手可以确保客户端和服务器双方都能收发数据,而两次握手只能确保从客户端到服务器的单向通信是可靠的。（ie 服务端发过但没收过）
2. **防止历史连接的建立**。如果只有两次握手,服务器无法确认客户端是否收到了自己的确认,可能会导致历史连接的错误建立。
   1. 客户端发送一个SYN包，但由于网络延迟，这个包在网络中滞留了很长时间，客户端认为连接失败，放弃了这次连接。一段时间后，那个延迟的SYN包终于到达了服务器。服务器不知道这是一个过期的连接请求，认为这是一个新的连接请求。服务器回复SYN-ACK。在两次握手的情况下，服务器会认为连接已经建立，开始分配资源。问题：客户端已经放弃了这个连接，不会再发送数据或确认。服务器却认为连接已经建立，白白占用资源等待数据。
3. **同步双方的序列号**。三次握手可以让双方都确认对方的初始序列号,这对于后续的可靠传输至关重要。

##### 为什么不是四次握手？

1. 三次握手就足够了。通过三次握手,双方已经能够确认各自的发送和接收能力都正常,无需再进行第四次握手。减少网络开销，提升效率
2. 可以优化为三次。在三次握手的第二步中,服务器同时发送SYN和ACK,相当于将第二次和第三次握手合并了。**如果分开发送,就会变成四次握手**。

#### 四次挥手

1. 客户端打算关闭连接，发送一个TCP首部FIN标志位被置为1的报文，也即FIN报文，报文中会指定一个序列号(seq=x)，然后客户端进入FIN_WAIT_1状态。
2. 服务端收到FIN报文后，回复ACK报文给客户端，且把客户端的序列号值+1(seq=x+1)，之后服务端进入CLOSE_WAIT状态，客户端进入FIN_WAIT_2状态。
3. **等待服务端处理完数据后**，也要断开连接，向客户端发送FIN报文，且指定一个序列号(seq=y+1)，之后进入LAST_ACK状态。
4. 客户端收到FIN报文后，发出ACK报文进行应答，并把服务端的序列号值+1(seq=y+2)，之后进入TIME_WAIT状态。**服务端在收到客户端的ACK报文后进入CLOSE状态，至此服务端已完成连接的关闭。客户端在等待2MSL没有收到回复，才关闭连接，进入CLOSED状态，至此客户端也完成连接的关闭。**

![picture 0](../images/321ea693246af4613b968fc5e453df16dfa7677bf61860a92c313992c54db289.png)  

> 主动关闭连接的，才有 TIME_WAIT 状态

##### 为什么是四次挥手？

- 关闭连接时，客户端向服务端发送FIN时，**仅仅表示客户端不再发送数据了但是还能接收数据**。
- 服务器收到客户端的FIN报文时，先回一个ACK应答报文，而服务端可能还有数据需要处理和发送，**等服务端不再发送数据时，才发送FIN报文**给客户端来表示同意现在关闭连接。

> 所以服务端的ACK和FIN一般都会分开发送，从而比三次握手导致多了一次

##### 为什么TIME_WAIT等待时间为2MSL

MSL: maximum segment lifetime，即任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。
网络中可能存在来自发送方的数据包，当这些发 送方的数据包被接收方处理后又会向对方发送响应，所以一来一回需要等待 2 倍的时间。

## 四、IP

### IP address

IPv4: 32bit, max = 2^32 < 43亿, 4组8bit
IPv6: 128bit, 与ipv4不兼容，8组16bit
> 暂省ipv6知识，p697

如何解决ipv4不够用的问题？
**革新派**
1.ipv6
**守旧派**
2.无分类地址与子网划分: 充分利用ip地址
3.地址转换技术NAT: 将私有ip->公有IP

互联网诞生之初，ip看起来蛮多的，科学家设计了ip地址分类
![picture 19](../images/86c33e9eda184ec6af5078ddc57417142edd90f921d7afdc74dff7fb5a6f3644.png){width=80%}

- 某网络号对应最大主机数计算：$2^{主机号位数}-2$，主机号全0表示网络本身，主机号全1表示广播地址
  - > 广播地址会给同一链路中相连的所有主机发送数据包
  - > 广播分为本地广播(广播给本网络的所有主机，**不会穿过路由器**，192.168.0.0/24的广播地址为192.168.0.255)和直接广播（在不同网络之间的广播，192.168.0.0/24向192.168.0.255/24发送数据包时，路由器会将其转发给192.168.0.1/24，从而.1网络下所有主机都可收到）（不常用）
- D类E类地址没有主机号，不可用于主机ip；D类用于多播
  - > 多播用于将数据包发送给特定组内的所有主机。由于广播不会穿过路由器，所以可以采用可以穿透路由的组播给其他网段发送同样的包。组播的28bit为组编号

ip分类的缺点：

1. 同一个网络/网段下无法组织**层次**（同一公司想要按部门划分层次） -> 子网划分
2. 不能很好地与现实网络匹配，C类地址就254个，不够用，B类6万多个又太多了，浪费。 -> CIDR

**子网划分**：通过**子网掩码**将主机地址划分为子网网络地址和子网主机地址

**无分类地址CIDR**也分为网络号和主机号，表示为`a.b.c.d/x; x属于[0,32]`，很灵活。
> 分类地址中x=7,14,21, CIDR是分类地址的泛化表示

---

公有ip和私有ip：
![picture 20](../images/9672b635d1a2ac34d4e027a7836686a6354c773521ae32c668f23636bddbb35f.png){width=80%}
私有ip由组织内部人员管理

---

IP地址与路由控制：
路由控制表中记录着**网络地址**与下一跳ip地址(路由器)。
在发送IP包时，首先要确定IP包首部中的目标地址，再从路由控制表中找到与该地址具有相同**网络地址**的记录，根据该记录将IP包转发给相应的下一个路由器。如果路由控制表中存在多条相同网络地址的记录，就**选择相同位数最多的网络地址**，也就是最⻓匹配。

---

ip分片与重组：
每种数据链路的最大传输单元MTU不同，eg以太网MTU1500, FDDI数据链路MTU=4352。当ip包大于MTU，就会被分片。
> 分片后的IP包只会在目标主机处重组，中间的路由器可不会重组。

---

环回地址
其实127开头的都是环回地址...不止127.0.0.1奥
一般来说，IPV4下使用`127.0.0.1`作为loopback addr，IPV4使用`::1`。

### IP related protocol

#### dns

DNS: domain name -> ip addr
refer to section 1

#### ARP

ARP: IP -> mac
refer to section 1

#### DHCP

Dynamic Host Configuration Protocol
基于UDP广播； 应用层协议
![picture 21](../images/dbed3a1a55f355505d52fa34cac1f1fcdfe2ff8d3824b8de5d4783be6d68b9d6.png)  

如果DHCP服务器和客户端不在一个局域网，路由器又不转发广播数据博，怎么进行UDP广播呢？
-> **DHCP中继代理**诞生，实现一个DHCP服务器统一管理不同网段的ip地址的分配
![picture 22](../images/31d43ffc962a3a9b0c5f3f68bde3b1c5c987797c30cb705eaff6c40efb5526c0.png)  

#### NAT/NAPT

抢救IPv4两大手段：无分类编址子网划分 && NAT

Network Address (Port) Translation
纯粹(愚蠢)的NAT：NAT路由器将一个私有IP映射到一个公有IP，没卵用。
改进版NAPT: NAT路由器将多个私有IP及其端口映射到一个公有IP。
![picture 24](../images/b1e8a6309d576a0765966ce2a537582c814ff422a8384f8491268a7e57218a1a.png){width=80%}

NAT最大的缺点：
公网主机无法主动与内网主机建立联系，因为转换变中还没有映射记录。
so **NAT穿透技术**

![picture 23](../images/7625686289a948d73d853542050ffe8f8d3a539fecef217d13e760272bec8293.png){width=80%}

#### ICMP/ping/traceroute

虽然ICMP和IP都是网络层协议，但ICMP是基于IP的（层内关系）

Internet Control Message Protocol
互联网控制报文协议

![picture 25](../images/e2faf9bba0eb33c9f7d297f50890b8c845b2a8c011a4a8540df82acb7e556596.png){width=70%}
> 目标不可达：又可分为：网络不可达、主机不可达、协议不可达、端口不可达、**需要分片但设置了不分片(traceroute)**
> 原点抑制：为了缓和网络拥堵问题
> 重定向消息：路由器发现发送端主机没使用最优路径发送数据，返回该消息包含了最合适的路径
> 超时：**当IP头部的TTL字段(time to live)减为0(traceroute)**(每路过一个路由器-1)，丢弃该ip包，路由器返回一个超时消息。

ICMP工作在网络层，封装在IP数据包内
![picture 4](../images/7df0409c3058cc3700683e19af534832a3c7c3f4d5c21bbef87e2e8c3eb2f50b.png){width=70%}

**ping**--基于查询报文类型 （**应用层**命令）
man ping: send ICMP ECHO_REQUEST to network hosts
ping基于ICMP**回送请求echo request**和(8类型)ICMP**回送应答echo reply**(0类型)这两种**查询**报文，如果可以返回ICMP echo reply，说明发送端主机(host)可以到达接收端主机。

> 翻墙后依然ping不通google的原因大概是：代理软件只代理HTTP等应用层协议，而ping是ICMP网络层协议，故而ICMP无法被代理软件代理。

ping的详细流程：

![picture 5](../images/3b588df5eb45ec8be1fb57a366b28b2dcb5c7b2f3eb91756365a6ee6d8ba91a3.png){width=80%}
> 设置**序号**是为了区分ping所发送的多个数据包，ping在发送echo request时会在报文数据本分插入发送时间戳，收到echo reply之后用当前时间戳减一手就知道**RTT**往返时间了。

ping与TCP发数据的区别：
![picture 6](../images/74e465883cf0840cc3dce3dd5bd612ec8a56c760bca5b066accf27b8f444aa23.png){width=80%}
> socket中SOCK_STREAM是TCP，工作在传输层，SOCK_RAW是原始套接字，工作在网络层，构成ICMP的数据。
> 所以本质上，ping和普通程序发消息在流程上没啥区别。

ping 127.0.0.1会发生什么：
![picture 8](../images/f16309427ee5fb1cc7bbcd434e521f0799c4b1199d8831e8c14e5cfbfcf27a5a.png){width=70%}

![picture 7](../images/f6c33bdaf53a6d07ccfdd3033ce0144ffb59de20e839091bfbc1fea83dbc0d14.png){width=80%}

---

ping 本机ip又会发生什么：
ping 本机ip与ping 环回地址一样，都会走“假网卡”（`ifconfig`中的`lo`本地环回接口）
即二者一样。

---

`localhost` is a **domain name**, will be parsed to IP address `127.0.0.1`, can be modified by `vim /etc/hosts`
`0.0.0.0`表示**本机的所有IPv4地址**。(用于socket服务端的listen ip)

```c
/* Address to accept any incoming messages. */ 
#define INADDR_ANY ((unsigned long int) 0x00000000) /* 0.0.0.0   */
```

![picture 9](../images/df1ba68b49b13edefcb31753888e29e910c4dd35d3c13389dcf380201a6c1696.png)  

---

**traceroute**--基于差错报文类型
man: print the route packets trace to network host
> windows中叫做tracert

原理：**故意设置特殊的TTL**来追踪去往目的地时所经过的路由器。
specifically, 将IP包的TTL生存期限从1开始按顺序递增，发送**UDP包**，强制接收**ICMP超时**消息。
> 当然有的路由器就不会返回这个ICMP，所以对于有的公网地址，是看不到中间经过的路由的。dont know why.

最后，当差错报文类型是**端口不可达**时，说明发送方发出的UDP包到达了目的主机。（traceroute发送UDP包时会填一个不可能的目的端口号(一般认为不会使用的)）

---

traceroute还有一个作用：
原理：**故意设置不分片**，来确定路径的MTU
> 以太网的数据链路上的MTU通常是1500字节，但是非以太网的MTU值就不一样了，所以我们要知道MTU的大小，从而控制发送的包大小

specifically, 发送端主机发送IP包时将IP首部的**分片禁止标志位设为1**，途中的路由器便不会对大数据包分片，会直接将其丢弃，然后返回一个**ICMP目标不可达消息**（包含**数据链路的MTU**）。该目标不可达消息就是：**需要进行分片但设置了不分片**。

`traceroute -F host`: -F; --dont-fragment

#### IGMP

Internet Group Managemant Protocol
首先，IGMP和ICMP没有任何关系。
前面说D类ip可以组播，那么如何管理一组？因特网组管理协议上线。

IGMP工作在**主机**(组播成员)和**最后一跳路由器**之间。
IGMP报文向路由器申请加入和退出组播组，默认情况下路由器是不会转发组播包到连接中的主机；主机申请加入到组播组时，路由器就会记录IGMP路由器表，路由器后续就会转发组播包到对应的主机了。
详细见p714，暂略。

## 二、物理层

1. 通信双方按**交互方式**分类：(**信号传输**有哪几种方式)
   1. 单工通信：又称为单向通信，即只能有一个方向的通信而没有反方向的交互。例：无线电广播，电视广播
   2. 半双工通信：又称为双向交替通信，即通信的双方都可以发送信息，但不能双方同时发送（当然也就不能同时接受）
   3. 全双工通信：又称为双向同时通信，即通信的双方可以同时发送和接受信息。
2. Some Conception
   1. 信道：信号的传输媒介。分为模拟信道和数字信道
   2. 码元传输速率（波特率）：单位时间传输的码元（脉冲）个数；
   3. 信息传输速率（比特率）：单位时间传输的比特数（二进制码元个数）；
   4. 比特率=波特率*1码元携带的比特数
   5. 奈氏准则：理想低通（没有噪声、带宽有限）的信道中，极限**码元**传输速率为2W波特。
   6. 香农定理：带宽有限、有噪声时信道的极限数据传输速率为Wlog2(1+S/N)
3. 数字数据编码成数字信号：归零编码、非归零、反向非归零、曼彻斯特、差分曼彻斯特

## 三、数据链路层

1. **透明传输**：由于使用特定的字符来表示帧的开始和结束，所以传输的内容中不能出现和帧定界符相同的字符，但这显然是不可能的，为了解决这个办法，就可以在内容中和帧定界符一样的字符前边加上规定好的**转义字符**，这种方法称为**字符填充**或者是**字节填充**。
2. 流量控制：
   1. 停止-等待协议：发送一帧就要应答一帧，必须等待应答发送方才能继续发送。
   2. 滑动窗口流量控制：发送方维持一组连续的允许发送的帧的序号，叫发送窗口。接收方也维持接受窗口。由接收方对发送方进行流量控制。

3. 滑动窗口：
   1. 停等协议：发1收1（窗口尺寸）；逐个确认、逐个接收
   2. GBN后退N帧协议：发[1, 2^n - 1]，收1；累计确认，逐个接收
   3. SR选择重传协议：发=收=2^(n-1)；逐个确认，可乱序接收
4. 介质访问控制
   1. 信道划分介质访问控制：频分复用（并行）、时分复用（并发）、波分复用（光的频分复用）、码分复用（信道复用技术，为了提升传输能力和资源利用率）
   2. 随机访问介质访问控制：ALOHA、CSMA（先听再发）、CSMA/CD、CSMA/CA（CA是碰撞避免）
      1. CSMA/CD（载波监听多点接入/碰撞检测协议）：（CD是碰撞检测；先听再发、边发边听、冲突停发、随机重发)
      2. CSMA/CA（载波监听多点接入/碰撞避免技术） Carrier Sense Multiple Access with Collision Avoidance

## 四、重点

5. TCP中的流量控制和拥塞控制
    注：tcp协议如何保证传输的可靠性
    **流量控制**主要针对的是端到端传输中控制流量大小并保证传输可靠性（未收到ack就不滑动）。流量控制往往  是指**点对点**通信量的控制，所要做的是抑制发送端发送数据的速率。
    **拥塞控制**主要是一个**全局性过程**，涉及到所有主机，路由器，以及与降低网络传输性能有关的所有因素。防  止过多的数据注入到网络中。如果有发生丢包则通过拥塞控制减小窗口，确定出合适(==慢启动 拥塞避免 快重传 快恢复==)的拥塞窗口（增性加乘性减）。
    1. 慢启动：不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小;
    2. 拥塞避免：拥塞避免算法让拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍，这样拥塞窗口按线性规律缓慢增长。
    3. 快重传：快重传要求接收方在收到一个 失序的报文段 后就立即发出 重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。
    4. 快恢复：快重传配合使用的还有快恢复算法，当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半，但是接下去并不执行慢开始算法：因为如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将cwnd设置为ssthresh的大小，然后执行拥塞避免算法。
![图 6](../images/ef9e426eafa483023fd78366ab6d9b3c45258cb15462abd4821e86673fd37de8.jpg)  

1. DHCP（Dynamic Host Configuration Protocol，动态主机配置协议）应用层协议；通常被应用在大型的局域网络环境中，主要作用是集中的管理、分配IP地址，使网络环境中的主机动态的获得IP地址，能够提升地址的使用率。DHCP协议采用客户端/服务器模型。

## 网络设备

- **网卡(NIC)/网络适配器**: network interface card/网络接口卡：将数字信号(由一系列01组成的网络包)转换为电信号或光信号，并通过网线或光纤发送出去，到达下一个集线器、路由器等设备
- **中继器(repeater)**: **物理层**面上延长网络的设备；半双工（碰撞现象）
  - 多口中继器又名中继集线器，简称**集线器**(repeater hub): ==无脑将电信号广播到所有端口==，不安全，浪费资源；
  - RJ-45 + PHY(MAU) + 中继电路
  - 广播，一次也只能转发一个包（否则碰撞）
- > 由于集线器会广播到所有端口，浪费资源且不安全。所以考虑单播，所以集线器 + MAC地址表。
- 网桥(bridge)/**二层交换机**: **数据链路层**面上连接两个网络的设备/连接不同终端；全双工
  - 多口网桥又名交换集线器，简称**交换机(switching hub)**: 高级集线器，只发送给目标MAC的端口，维持MAC地址表（MAC->物理端口）；
  - RJ-45 + PHY(MAU) + MAC模块 + 缓冲区 + 交换电路
  - (切记**交换机MAC模块不具有MAC地址**，直接接受所有的包存放到缓冲区，然后由交换电路根据MAC地址表进行包转发到相应端口)
  - 一次可以转发多个包
  - 交换机只是转发包，不会成为发送方或接收方
  - 交换机在地址表中匹配完全一致的MAC
  - 交换机中对 MAC 地址表的维护是包转发操作中的一个步骤
- > 由于交换机不具备独立MAC，当连接另一个交换机的时候需要为另一个交换机上连接的所有电脑的mac都做一个映射，映射表太大了，所以考虑给交换机 + MAC，
- **路由器(router)/三层交换机/网关(gateway)**: **网络层**面上连接两个网络的设备，每一个端口都有独立MAC
  - 端口模块(eg ADSL, FTTH, 无线局域网, 以太网) + 包转发模块(路由表)
  - 路由器的各个端口都具有MAC地址和IP地址
  - 路由器会作为发送方从相应端口发送
  - 路由器在地址表中仅匹配网络号部分，忽略主机号
  - 路由器中对路由表的维护是与包转发操作相互独立的
  - 补充：
  - 光猫/数字调制解调器/翻译(modem): 将光纤的光信号转换为网络信号，然后路由器才能联网
  - 光猫一定有光纤输入接口吧，然后现在的光猫很多有路由功能，但据说比较菜
  - 路由器wan口接光猫，lan口接电脑，还有wifi

![图 8](../images/3dcf0d51796942146ef20a05055e9780d1f29e3cc8d6b69fe458893f45f5fe35.png)