# Redis八股

- [Redis八股](#redis八股)
  - [基础](#基础)
    - [什么是Redis](#什么是redis)
    - [redis可以用来做什么](#redis可以用来做什么)
    - [为何要用Redis作为MySQL的缓存](#为何要用redis作为mysql的缓存)
    - [Redis数据结构](#redis数据结构)
      - [Redis数据结构及使用场景](#redis数据结构及使用场景)
      - [实现方式](#实现方式)
      - [Zset的底层实现](#zset的底层实现)
    - [Redis线程模型/网络模型](#redis线程模型网络模型)
      - [Redis为什么快](#redis为什么快)
      - [Redis是单线程还是多线程](#redis是单线程还是多线程)
      - [redis哪些地方使用了多线程](#redis哪些地方使用了多线程)
      - [redis网络模型](#redis网络模型)
  - [缓存](#缓存)
    - [数据库与缓存的一致性](#数据库与缓存的一致性)
    - [缓存穿透 雪崩 击穿](#缓存穿透-雪崩-击穿)
      - [缓存穿透](#缓存穿透)
      - [缓存雪崩](#缓存雪崩)
      - [缓存击穿 / 热点key问题](#缓存击穿--热点key问题)


## 基础

### 什么是Redis

Redis: Remote Dictionary Service

* Redis是一种基于键值对(key-value)的**NoSQL**数据库，对数据的读写操作都是在**内存**中完成，因此读写速度非常快，常用于**缓存cache**，**消息队列mq**、**分布式锁**等场景
  * redis可以将内存数据持久化到磁盘上，并不会断电丢失
* Redis提供了多种数据类型来支持不同的业务场景，并且**对数据类型的操作都是原子性**的，因为执行命令由单线程负责的，**不存在并发竞争的问题**
* Redis还支持**事务、持久化、Lua脚本、多种集群方案（主从复制模式、哨兵模式、切片机群模式）、发布/订阅模式，内存淘汰机制、过期删除机制**等等。

### redis可以用来做什么

1. **缓存**：由于所有数据都存在内存中，读写速度远超基于磁盘存储的数据库(mysql)，所以使用redis作为缓存可以极大地提高应用的响应速度和吞吐量
2. **分布式锁**：Redis可以实现分布式锁，用来控制跨多个进程或服务器的资源访问
3. **消息队列**：充当简单的消息队列，依赖发布/订阅模式(Pub/Sub)
4. **排行榜**/计数器：Redis的ZSet非常适合用来实现排行榜的功能，同时Redis的原子递增操作可以用来实现计数器功能

### 为何要用Redis作为MySQL的缓存

源于：**高性能**和**高并发**两种特性

* 高性能：首次通过mysql从磁盘读取，很慢，缓存到redis后相当于直接操作内存，很快
* 高并发：单台设备的**Redis的QPS(Query Per Second)是mysql的10倍**，**redis单机的QPS可轻松突破10w，而mysql单机QPS很难超过1w**；故而直接访问redis可承受的请求远超过mysql；顺便可以很好地降低后端的负载

但缓存存在一定的成本：

* 数据一致性成本
* 代码复杂度上升
* 集群维护成本上升

![picture 10](../images/88a07ce85d74b61fee28c9bd4143f1e21ee2b43234e9ff6155c54d9b9f91f0ef.png){width=80%}

### Redis数据结构

#### Redis数据结构及使用场景

* 常见的有五种数据类型
  * String类型的应用场景：缓存对象、常规计数、分布式锁、共享 session 信息等
  * List类型的应用场景：消息队列（但是有两个问题：1. 生产者需要自行实现全局唯一 ID；2. 不能以消费组形式消费数据）等。
  * Hash类型：缓存对象、购物车等。
  * Set类型：聚合计算（并集、交集、差集）场景，比如点赞、共同关注、抽奖活动等。
  * 有序集合Zset类型：排序场景，比如排行榜、电话和姓名排序等。
* 新版本新增四种
  * 位图BitMap（2.2 版新增）：二值状态统计的场景，比如签到、判断用户登陆状态、连续签到用户总数等
  * HyperLogLog（2.8 版新增）：海量数据基数统计的场景，比如百万级网页 UV 计数等；
  * 地理空间GEO（3.2 版新增）：存储地理位置信息的场景，比如滴滴叫车；
  * 消息队列Stream（5.0 版新增）：消息队列，相比于基于 List 类型实现的消息队列，有这两个特有的特性：自动生成全局唯一消息ID，支持以消费组形式消费数据。

![picture 4](../images/b8d6ec9aa02b299d1cb9740d1c661e91488b27ba826975f10ef661b1a231f8fe.png)  

#### 实现方式

暂略

#### Zset的底层实现

Zset的底层数据结构是由 **压缩列表 或 跳表** 实现
如果有序集合的元素个数小于 128 个，并且每个元素的值小于 64 字节时，Redis 会使用压缩列表作为 Zset 类型的底层数据结构；
如果有序集合的元素不满足上面的条件，Redis会使用跳表作为Zset类型的底层数据结构；

### Redis线程模型/网络模型

> 请先复习`os_essence.md`中Linux的5中IO模型

#### Redis为什么快

单线程的reids吞吐量10w/s

之所以redis核心是单线程还这么快的原因：

* 纯内存操作
* 避免多线程切换和线程安全
* IO多路复用

#### Redis是单线程还是多线程

如果说的是Redis的核心业务部分(命令部分)，答：单线程（即使是最新的redis
如果聊整个Redis，答：多线程

**redis为何坚持使用单线程？**

* redis是**纯内存操作**（抛开持久化不谈），执行速度很快，他的性能瓶颈是**网络延迟或内存**而非**CPU**，因此多线程不会带来巨大的性能提升
  * IO多路复用的提升相比于纯内存并不多
* 多线程会导致过多的**上下文切换**(线程数超过核数)，带来不必要的开销
* 线程**安全**问题，必然要引入线程锁这种安全手段，复杂度增高，性能降低，还不兼容
* redis采用**IO多路复用**机制处理大量的客户端socket请求，实现一个线程处理多个并发的IO操作

#### redis哪些地方使用了多线程

* Redis单线程指的是==接收客户端请求->解析请求 ->进行数据读写等操作->发送数据给客户端这个过程是由一个线程（主线程）来完成的==

* 但Redis程序并不是单线程的，Redis在启动的时候，是会**启动后台线程**（BIO）的：包括一个**关闭文件线程、AOF刷盘线程和一个lazyfree线程异步释放内存**(比如删除大key的`unlink key`)
  * 因为这几个任务挺耗时的，交给主线程来干的话，容易阻塞
* reids6.0采用多个IO线程处理网络请求，来解决网络IO的瓶颈

#### redis网络模型

redis使用epoll()实现IO多路复用，多个客户端连接服务端时，Redis会将客户端socket的fd注册进epoll红黑树，然后epoll同时监听多个fd，如果有数据来了就通知事件处理器赶紧处理，这样就不会存在**服务端一直等待某个客户端给数据**的情形

6.0之前redis的IO多路复用模式使用的是**单Reactor单线程模式**
6.0之后将网络IO部分改成了多线程

## 缓存

### 数据库与缓存的一致性

当我们将数据缓存到redis之后，如果修改了数据库，肯定要同时给缓存数据改了，不然不乱套了...此即缓存更新策略

缓存更新策略：

* **内存淘汰**：啥也不干，开摆；利用redis自己的内存淘汰策略：内存不足时自动淘汰部分数据，下次再查询就可以更新了（很牵强...一致性很差；eg LRU, LFU算法
* **超时剔除**：给缓存数据设置TTL，到期后自动删除缓存，下次查询时更新缓存（一致性一般般..修改数据库后直到ttl到期前都不一致
  * 作为兜底方案
* ==**主动更新**==：自己写业务逻辑，更新数据库时同时更新缓存（一致性很好，但累啊
  * Read/Write Through(读穿/写穿)策略：将缓存和数据库整合为一个服务,由该服务来维护一致性。应用程序只需要与这个服务交互,无需关心缓存一致性问题。（就直接依赖别人的服务，透明
  * Write-Back / Write-Behind 写回策略：调用者**只操作缓存**, 由其他线程异步地将缓存数据**定期**持久化到数据库, 保证最终一致性。但缓存变了到写回之前依然不一致；此外如果此时redis宕机了就寄了
  * ==**Cache Aside/旁路缓存策略(唯一神)**==：由缓存的调用者，在更新数据库的**同时**更新缓存
    * 写策略：==**先**更新数据库，再**删除**缓存==


综上所述，缓存更新策略最佳实践：

* 对于低一致性需求：使用Redis自带的内存淘汰机制即可。比如店铺**类型**的缓存，很久不会变咯
* 对于高一致性需求：主动更新 + 超时剔除兜底
  * 读操作：先查缓存，命中直接返回，未命中再去查数据库，并写入缓存，**设置ttl**
  * 写操作：先更新数据库，再删除缓存；还要保证原子性

### 缓存穿透 雪崩 击穿

#### 缓存穿透

**缓存穿透**问题：客户端请求的数据在缓存和数据库中都不存在，导致每次查询都会绕过缓存直接打到数据库，对数据库造成巨大压力（攻击数据库的好办法）；即**大量无效请求直接打到数据库**
> Cache Penetration 其实翻译为'渗透'挺好（不怀好意者通过这个漏洞避开redis渗透到mysql

应对方案：

* 主动方案（不让被穿透）/ 限制非法请求
  * 增加id的复杂度，避免被猜出来id规律；
  * 增加id格式校验(比如删除0)；
  * 增强用户校验(限流等)
* 被动方案（穿透了再去弥补）
  * **缓存空对象**（简单粗暴
    * 消耗额外内存（我编各种各样的id打给你，你都得存着，但也可以通过ttl(2min)解决，但还是有点难受，项目中采用bloom filter
    * **可能造成短期的不一致**：我们在缓存了null之后，此时我们真的给数据库插入了要请求的新数据，但redis还是会返回null，走不到数据库 -> 只能控制ttl来缓解了，或者你数据库新增数据时去redis覆盖一下 
  * **Bloom布隆过滤**（省内存，但复杂，存在误判可能
    * 在写入数据库数据时，使用布隆过滤器做个标记，然后在用户请求到来时，业务线程确认缓存失效后，可以通过查询布隆过滤器快速判断数据是否存在，如果不存在，就不用通过查询数据库来判断数据是否存在。即使发生了缓存穿透，大量请求只会查询 Redis 和布隆过滤器，而不会查询数据库
    * 查询布隆过滤器说**数据存在，并不一定证明数据库中存在这个数据，但是查询到数据不存在，数据库中一定就不存在这个数据**

#### 缓存雪崩

同一时段**大量的缓存key同时失效(TTL同时到期)**或**Redis服务器宕机**，导致大量请求打到数据库，可能给数据库干崩溃，引起整个系统都崩了

解决方案：

* 大量的缓存key同时失效
  * **均匀设置过期时间**（给不同的Key的TTL添加随机值
* Redis服务器宕机
  * **构建Redis缓存高可靠集群**：通过主从节点的方式构建Redis缓存高可靠集群。主节点废了，从节点顶上
  * 牺牲部分服务
    * **服务熔断机制**：暂停业务应用对缓存服务的访问，直接返回错误，不用再继续访问数据库（全部请求都无法工作
    * **请求限流机制**：只将少部分请求发送到数据库进行处理，再多的请求就在入口直接拒绝服务，等到Redis恢复正常并把缓存预热完后，再解除限流

#### 缓存击穿 / 热点key问题

指缓存中某个热点key过期的瞬间，大量并发请求直接打到数据库，干废数据库

> (eg 秒杀活动相关，被高并发访问)，最好还要求该key**缓存重建**(从数据库拿数据到redis)比较复杂（更难顶

可以认为缓存击穿是缓存雪崩的子集(一个是热点key挂了，一个是大量key挂了)
![picture 8](../images/fc1345f209763180b6352d88494853e34d968a88e11444aae61978f2112c36d8.png){width=80%}

解决方案：

* 互斥锁：只让一个线程去重建缓存，未能获取互斥锁的请求，等待锁释放后重新读取缓存（那也太难顶了
  * 互斥锁选择了**一致性**，但很慢啊，**可用性**很低啊(CAP问题)
* 逻辑过期：不给热点数据设置TTL，那就不会失效咯；但要额外设置一个过期时间字段，当真的过期了，得创建线程去重建啊，总不能真的永久TTL不更新吧（笑
  * 逻辑过期选择了**可用性**，但不保证**一致性**，大家直接拿了旧数据就行了，第一个请求线程另开一个线程去重建缓存

![picture 9](../images/05997c554e834ad7bd6a30145a6b4847e0fb22be71898d5cdd20d672566a2fb1.png)  
