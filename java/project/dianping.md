# 黑马点评

[toc]

## alias & bg

驴友社区
描述：该项目是一个创新的旅游项目，为用户提供了丰富的旅游体验和便捷的功能，包括短信登录、景点查询、优惠券秒杀、附近的景点推荐、用户签到、旅行圈好友关注和动态点赞排行榜等功能；

秒享生活
基于Redis+SpringBoot的生活服务类App,实现了短信验证码登录查找店铺，秒杀优惠券，发表点评，关注推送的完整业务流程。

## 登录功能

使用Redis解决了在集群模式下的Session共享问题，使用双拦截器实现用户的登录校验和权限刷新。
实现手机短信登录功能，并使用Redis实现Session token的存储，解决服务器集群中共享登录用户信息问题；采用双拦截器实现刷新token有效期和鉴权功能。

### 基于Session的短信登录

**发送验证码：**
用户在提交手机号后，服务端会校验手机号是否合法，如果不合法，则要求用户重新输入手机号 如果手机号合法，后台此时生成对应的验证码(RandomUtil)，同时将验证码进行保存(session.setAttribute)，然后再通过短信的方式将验证码发送给用户(我只是模拟了下，可以借助阿里云短信服务)

**短信验证码登录、注册：**
用户输入手机号和验证码，后台从session中拿到当前验证码(session.getAttribute)，然后和用户输入的验证码进行校验，如果不一致，则无法通过校验，如果一致，则后台根据手机号查询用户，如果用户不存在，则为用户创建账号信息，保存到数据库(通过mybatisplus)，无论是否存在，都会将用户信息保存到session中，方便后续获得当前登录信息

**校验登录状态（通过===拦截器==对一些路径进行拦截）:**
用户在请求时候，会在cookie中携带者sessionId到后台，**后台通过sessionId从session中拿到用户信息**，如果没有session信息，则进行拦截，如果有session信息，则将用户信息保存到threadLocal中，并且放行

![picture 0](../../images/9cfa785533e5b7d34ffe66d02d20f8afcfac04c6624622f97b1f9b072634d844.png)  

#### 为什么要把用户信息保存到ThreadLocal中？

ThreadLocal可实现线程隔离：ThreadLocal为每个线程提供独立的变量副本，各个线程可以独立地改变自己的副本，而不会影响其他线程的副本；ThreadLocal的本质类似HashMap；

在处理单个web请求时，由一个线程负责。（即使服务器使用线程池，在单个请求的生命周期内，处理该请求的线程是不变的。）

在Web应用中，将用户信息保存到ThreadLocal中的主要目的是为了**在当前处理的线程中**方便、 快捷地获取用户相关信息，而不需要频繁地从Session或其他存储中检索。这样做有以下几个好处：

* 线程安全：ThreadLocal为每个线程提供了其自己的变量副本。这意味着一个线程不能访问或修改另一个线程的ThreadLocal变量。这在多线程环境中特别有用，因为它避免了共享数据时的同步问题
* 性能优化：从Session或其他存储中检索用户信息可能涉及数据库查询或网络调用，这可能会消耗相对较多的时间和资源。通过将用户信息保存在ThreadLocal中，可以在需要时快速访问，减少了不必要的查找和等待时间
* 请求作用域数据的传递：在Web应用中，一个请求通常由多个过滤器、拦截器、服务层方法等共同处理。使用ThreadLocal可以确保这些组件在处理请求时都能访问到相同的用户信息，而不需要显式地传递数据。

在使用ThreadLocal时，要确保在请求处理完毕后及 时清理其中的数据，避免内存泄漏。这通常通过在请求处理完毕后调用 ThreadLocal的remove()方法来实现

#### 登录校验拦截器详解

![picture 1](../../images/6866ee00629f2f93a07c072de37db894564aaccc53d8084d8394db000e1d5022.png)

在项目中，有很多Controller，随着业务的开发，**越来越多的业务都需校验用户的登录**，不可能在每一个业务的Controller类中都编写“校验登录状态”的逻辑。在SpringMVC中，拦截器可以在所有Controller执行之前去做，有了拦截器之后，用户的各种请求就不用直接访问Controller，必须先经过拦截器，判断是否放行。可以把用户校验登录的功能交给拦截器做，但是需要把拦截器中拿到的用户信息传递到各个Controller层去，传递的过程中还需注意线程安全问题。那么在拦截器中拦截到的用户信息，可以保存到ThreadLocal中。

ok，到这儿基于session登录结束，但有集群的session共享问题

#### 利用redis解决集群的session共享问题

每个tomcat中都有一份属于自己的session,假设用户第一次请求被负载均衡服务器分配到了第一台tomcat，并且把自己的信息存放到第一台服务器的session中，但是第二次这个用户被负载均衡到第二台tomcat，那么在第二台服务器上，肯定没有第一台服务器存放的session，所以此时整个登录拦截功能就会出现问题，我们如何解决这个问题呢？

早期的方案是session拷贝来共享，就是说虽然每个tomcat上都有不同的session，但是每当任意一台服务器的session修改时，都会同步给其他的Tomcat服务器的session，这样的话，就可以实现session的共享了，但这有两个问题：每台服务器中都有完整的一份session数据，服务器压力过大；session拷贝数据时，可能会出现延迟

解决方案：**使用Redis实现共享session登录，主要是为了解决在分布式系统中，用户session无法共享的问题。**因为传统的session是存储在服务器端的内存中，当请求分发到不同的服务器时，就无法获取到用户的session信息。而Redis作为一个内存数据库，具有高性能、高并发、持久化等特点，非常适合用来存储和共享session。

redis替代session实现登录注册功能的好处：

* 分布式支持与扩展性：Redis更适合分布式系统，可以很容易地进行横向扩展，通过增加节点来扩展系统的容量和性能。在多服务器环境下，Redis可以作为中央session存储，而传统内存session难以在多服务器间共享。
* 持久化：Redis提供了多种持久化方式，可以将数据持久化到磁盘上，确保数据不会因为系统故障或者重启而丢失而服务器内存中的session在服务器重启后会丢失。
* 灵活性： Redis提供了丰富的数据结构和操作命令，可以灵活地处理各种数据存储和操作需求。在实现登录注册功能时，可以利用Redis的字符串、哈希表、列表等数据结构来存储用户信息、会话数据等，以及利用Redis的原子操作来实现并发安全的会话管理。

#### 权限刷新拦截器详解

我们通过拦截器进行获取token(从http请求头获取)、查询Redis用户、刷新token有效期(expire)的操作。
而如果将权限刷新功能写到登录校验拦截器中，该拦截器A只会拦截需要登陆的路径。
解决：在这个拦截器A前再加一个拦截器B，用于拦截所有路径，把获取token、查询Redis用户、刷新token有效期的操作放到这个拦截器B上做。而拦截需要登陆的路径的拦截器A只需要判断ThreadLocal中有没有用户即可

![picture 2](../../images/af34cc78c69e15bd951872cc1ba5864cb996a46d6237d86b88c8e38f450bd2c7.png)  
