# hmall

- [hmall](#hmall)
  - [begin](#begin)
    - [单体架构 vs. 微服务架构](#单体架构-vs-微服务架构)
      - [有什么拆分原则/目标](#有什么拆分原则目标)
    - [SpringCloud](#springcloud)
      - [你用过那些微服务组件 / 概括](#你用过那些微服务组件--概括)
  - [注册中心](#注册中心)
    - [为什么本项目需要注册中心](#为什么本项目需要注册中心)
    - [注册中心功能](#注册中心功能)
    - [注册中心原理](#注册中心原理)
      - [负载均衡算法 load balancer](#负载均衡算法-load-balancer)
  - [远程调用](#远程调用)
    - [HTTP vs. RPC](#http-vs-rpc)
    - [Feigh vs. Dubbo](#feigh-vs-dubbo)
    - [Feign是什么](#feign是什么)
    - [Feign如何实现负载均衡 / Ribbon](#feign如何实现负载均衡--ribbon)
    - [常见负载均衡算法](#常见负载均衡算法)
      - [一致性哈希算法](#一致性哈希算法)
    - [服务端/七层负载均衡 vs. 客户端负载均衡](#服务端七层负载均衡-vs-客户端负载均衡)
  - [网关](#网关)


TODO: 最后的视频笔记中有讲解如何切换负载均衡算法（我可以改造为加权轮询或者一致性哈希算法

![picture 0](../../images/a396ef237ee36cc0eed530d09019288900bcd7917b03fbe564e64b1c442d7a5f.png)  

---

* 通过Nacos作为注册中心，实现服务的注册与发现
* 利用OpenFeign实现各个微服务之间的远程调用，简化服务间的通信过程

## begin

### 单体架构 vs. 微服务架构

单体架构(monolithic structure): 整个项目中所有功能模块都在一个工程中开发；项目部署时需要对所有模块一起编译、打包；所有的组件（如用户界面、业务逻辑和数据库）都紧密耦合在一起，通常在同一个代码库中进行开发和部署。

* 优点
  * 简单，易于理解和开发，适合小型项目
  * 方便运维部署
  * 资源共享，节约成本
* 缺点
  * 团队协作成本高：不同模块的代码之间物理边界越来越模糊
  * 系统可用性差：某个模块的故障可能导致整个应用崩溃；**一些热点功能会耗尽系统资源**，导致其它服务低可用

微服务架构将应用程序拆分为多个小型、独立的服务，每个服务专注于特定的功能。服务之间通过API进行通信，能够独立部署和扩展。
> 本项目中：把商品、用户、购物车、交易等模块拆分，可以交给不同的团队去开发

* 缺点：
* 系统复杂性增加：一个服务拆成了多个服务，整体系统的复杂性增加，需要处理服务之间的**通信、部署、监控和维护**等方面的复杂性
* 服务间通信开销：微服务之间通过网络进行通信，传递数据需要**额外的网络开销和序列化开销**，可能导致性能瓶颈和增加系统延迟
* 数据一致性和事务管理：**每个微服务都有自己的数据存储**，**数据一致性和跨服务的事务管理**变得更加复杂
* 服务治理和版本管理：随着微服务数量的增加，**服务的治理和版本管理变得更加复杂**。需要考虑服务的**注册发现、负载均衡、监控和故障处理**等方面，以确保整个系统的可靠性和稳定性

#### 有什么拆分原则/目标

* 高内聚：每个微服务的职责要尽量单一，包含的业务相互关联度高、完整度高
* 低耦合：每个微服务的功能要相对独立，尽量减少对其它微服务的依赖，或者依赖接口的稳定性要强

> 本项目按照业务进行**纵向划分**为：用户服务、商品服务、订单服务、购物车服务和支付服务
> 横向划分：将各个功能模块之间的公共业务部分抽离出来作为通用服务

### SpringCloud

SpringCloud是java领域最全的微服务组件的集合

目前主流的微服务开源解决方案：

* Spring Cloud Alibaba项目：包括 Nacos（服务注册与发现、配置管理）、Sentinel（流量控制、熔断降级）、RocketMQ（消息队列）等组件，以及与 Alibaba Cloud（阿里云）的集成
* Spring Cloud Netflix: 结合了Netflix开源的多个组件，但是Netflix自2018年停止维护和更新
* Dubbo是一个高性能、轻量级的Java微服务框架（更多地被认为是一个高性能的RPC框架）

#### 你用过那些微服务组件 / 概括

![picture 2](../../images/caf998a46242a787f3945b838331cf1e048720b780d2ad791f97797753b6b646.png)

* 注册中心：**注册与发现服务**，管理微服务的地址中心；常用实现：
  * Netflix: Eureka `[juˈriːkə]`, Consul
  * Ali: Nacos
* 配置中心：集中管理微服务的**配置信息**，可以动态修改配置而无需重启服务；常用实现：
  * Netflix: Spring Cloud Config
  * Ali: Nacos Config
* 远程调用：在不同微服务之间进行**通信和协作**；常见实现：
  * RESTful APO: e.g., RestTemplate, Feign
  * RPC: e.g., Dubbo, gRPC
* API网关：作为微服务架构的**入口**，统一暴露服务，并提供路由、负载均衡、安全认证等功能；常见实现：
  * Netflix: Zuul, Gateway
  * Ali: Gateway, Apisix
* 分布式事务：保证跨多个微服务的**一致性和原子性**操作。常用实现：
  * Ali: Seata
* 熔断器：防止微服务之间的**故障扩散**，提高系统的容错能力。常用实现：
  * Netflix: Hystrix
  * Ali: Sentinel, Resilience4j
* 限流和降级：防止微服务**过载**，对请求进行限制和降级处理。常用实现：
  * Netflix: Hystrix
  * Ali: Sentinel

## 注册中心

**本项目中**：将商品和购物车拆为了两个服务，然后我们查询购物车时需要查询商品信息，因为我们查询购物车列表时，要判断商品最新的价格和状态，这样可以让用户看到商品涨价及降价信息(price字段)，以及是否还有库存(stock库存字段)，我们单体架构时大家在一个服务中，可以直接本地调用item的查询功能，然而拆分之后，**我们如何在服务cart-service中实现对服务item-service的查询呢?**

立即答：**把原来的本地方法调用改为跨微服务的远程程序调用(Remote Procedure Call (RPC))**
> RPC的实现方式可以: 基于HTTP协议(RestTemplate)，也可以基于Dubbo协议

![picture 4](../../images/91b8b1ca909829b15a7702cc925e7a0bec51ab9c2ac0d810cff36d119cec40f3.png)

我们可以通过RestTemplate发送http请求（包括请求方式、路径、参数、返回值）

```java
ResponseEntity<List<ItemDTO>> response = restTemplate.exchange(
        "http://localhost:8081/items?ids={ids}", // NOTE 问题：IP被写死了
        // 引入nacos后，可以通过自定义的负载均衡算法动态获取URI
        HttpMethod.GET,
        null,
        new ParameterizedTypeReference<List<ItemDTO>>() {
        },
        Map.of("ids", CollUtil.join(itemIds, ","))
);
```

### 为什么本项目需要注册中心

如果item-service进行了多实例部署(不同ip和port)来应该高并发，那么RestTemplate是不知道要去哪个ip和port的，上面这个url没法写...等问题

即**服务治理问题**：**调用者不知道服务提供者的地址，不知道该调哪个，临时部署的实例调用者也不知道** -> 所以我们需要注册中心/家政公司来统一管理

### 注册中心功能

注册中心主要用于**注册服务和发现服务**，用来管理和维护分布式系统中各个服务的地址和元数据的组件；

### 注册中心原理

> 服务中心占据一个ip和port：nacos的端口为`8848`
> 一个服务提供者可能有多个**实例**，每个实例都对应一个ip和port(可以理解为对应着一台服务器吧，至少是一个应用程序)

即服务中心、服务提供者和服务消费者之间的关系

![picture 5](../../images/0e00e02ef550f5fc791e42a3c7ebbb37c61f6e1bea8850b3d2d62094c8bd8537.png)  

基本流程如下：

* 服务提供者启动时就会**注册**自己的服务信息（服务名(`item-service`), IP, port）到注册中心
* 服务调用者可以从注册中心**订阅**想要的服务(通过服务名吧)，获取服务对应的**实例列表**（1个服务可能多实例部署）
* **服务调用者==自己==对实例列表负载均衡**，挑选一个实例
  * 为什么是调用者进行负载均衡而非提供者？
* 服务调用者向该实例发起**远程调用**

**当服务提供者的实例宕机或者启动新实例时，调用者如何得知呢？**

* 服务提供者会定期向注册中心发送请求，报告自己的健康状态（**心跳请求**）
* 当注册中心长时间收不到提供者的心跳时，会认为该实例宕机，将其从服务的实例列表中剔除
* 当服务有新实例启动时，会发送注册服务请求，其信息会被记录在注册中心的服务实例列表
* 当注册中心服务列表变更时，会**主动通知微服务**，更新本地服务列表（**推送变更**

#### 负载均衡算法 load balancer

服务调用者必须利用负载均衡的算法，动态地从nacos中多个实例中挑选一个实例去访问

* 随机
* 轮询
* IP的hash
* 最近最少访问

## 远程调用

TCP协议：作为传输层协议，TCP提供可靠的字节流传输，但在使用时会遇到“粘包”问题，即接收端无法区分消息边界。为了解决这个问题，开发者需要在TCP之上定义自定义协议。于是诞生了RPC和HTTP。
RPC 本质上不算是协议，而是一种调用方式。而像gRPC和Thrift这样的具体实现，才是协议，它们是实现了RPC调用的协议。目的是希望程序员能像调用本地方法那样去调用远端的服务方法。同时RPC有很多种实现方式，不一定非得基于TCP协议。

### HTTP vs. RPC

* 服务发现：HTTP使用DNS解析域名获取IP地址，而RPC通常依赖于中间服务（如Consul, nacos）来管理服务名与IP的映射
* 连接管理：HTTP1.1保持长连接以复用，而RPC协议通常会使用连接池来提升性能。
* 数据传输内容：HTTP主要传输字符串数据，使用JSON进行序列化，十分冗余；而RPC可以使用更高效的序列化协议（如Protobuf），性能上更优，这也是为什么企业内部微服务抛弃HTTP而使用RPC的主要原因
  * read: [link](https://javaguide.cn/distributed-system/rpc/http_rpc.html#http-%E5%92%8C-rpc-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB)

### Feigh vs. Dubbo

Feigh和Dubbo都是用于实现远程调用的框架，Feign基于HTTP，Dubbo基于RPC

![picture 6](../../images/ae955cee266f309bdddee1d0b48857498722d8f0046211c5b5aeaed8fbeee0e1.png)  

### Feign是什么

* Feign是一个声明式web客户端,它简化了使用基于 HTTP 的远程服务的开发。
  * > 声明式接口：开发者只需定义一个接口，并通过注解来描述HTTP请求的细节。Feign会根据这些定义自动生成相应的实现类。
* Feign是在**RestTemplate**和**Ribbon**的基础上进一步封装，使用RestTemplate实现Http调用，使用Ribbon实现负载均衡。
  * OpenFeign目前支持两种负载均衡策略：Ribbon和Spring Cloud LoadBalancer，但随着时间的发展，Spring Cloud LoadBalancer 正逐渐取代 Ribbon。


主要特点和功能：

* 声明式API：开发者只需要定义一个接口，并通过注解来描述HTTP请求的细节，Feign会根据这些定义自动生成实现类（动态代理）。通过使用注解，开发者可以轻松地指定URL、HTTP方法、请求参数、请求头等信息，使得远程调用变得非常直观和易于理解。

```java
// 定义Feign客户端接口
@FeignClient(name = "userFeignClient", url = "https://jsonplaceholder.typicode.com/")
public interface UserFeignClient {

    // 定义获取用户信息的方法
    @GetMapping("/users")
    ResponseEntity<List<User>> getUsers();
}
```

---

项目中写法:

```java
@FeignClient("item-service") // 去注册中心拿到实例列表
public interface ItemClient {
    @GetMapping("/items")
    List<ItemDTO> queryItemByIds(@RequestParam("ids") Collection<Long> ids);
}
```

OpenFeigin/Feign的工作原理:

* **Feign接口声明**: 开发者定义一个接口,并使用@FeignClient注解标记服务名称,以及使用SpringMVC注解声明请求方式、路径、参数等信息
* **动态代理生成**: Feign在运行时会为这个接口生成一个**动态代理实现类**,实现类会根据接口上的注解信息构造出正确的HTTP请求
  * 动态代理实现类是FeiginInvocationHandler，里面的invoke函数：首先根据接口的注解**构造http请求**(但没有ip和port)
* **负载均衡**：loadBalancer.choose()会通过Ribbon提供的默认**负载均衡**算法从注册中心中挑选一个实例/节点(将`item-service`负载均衡为`ip+port`)，然后重构URI即可，然后下一步发送http请求
* 响应结果处理: 请求返回后,Feign 会根据接口声明的返回值类型,自动将响应结果转换为对应的对象

### Feign如何实现负载均衡 / Ribbon

Ribbon是Netflix开源的一个**客户端负载均衡器**，可以与Feign无缝集成。Ribbon通过**从服务注册中心获取可用服务列表**，并通过**负载均衡算法**选择合适的服务实例进行请求转发，实现**客户端**的负载均衡。

OpenFeign默认采用RoundRibbonLoadBalancer

### 常见负载均衡算法

> 负载均衡器 load balancer: Ribbon/Gateway; 一般都支持下面的算法

![picture 7](../../images/b2064b7a03d66fc2f0a71118f48f3d96cf4d3649a288190210ef73ad14133dee.png){width=70%}

* **简单轮询**（Round Robin）：请求按顺序分配给每个服务器，简单易用，适合服务器性能相近的场景。
* **加权轮询**（Weighted Round Robin）：RR + 权重。根据服务器自身的性能给服务器设置不同的权重，将请求**按顺序和权重分**发给后端服务器，可以让性能高的机器处理更多的请求
  * 无法应对**水平切分**的分布式数据库系统，因为每个服务器节点存的数据不同；比如一个分布式KV缓存系统，某个key应该到哪个或者哪些节点上获得，应该是确定的，不是说任意访问一个节点都可以得到缓存结果的。遂**哈希算法**
  * 水平切分：是将同一张表的数据按行拆分到多个数据库中，例如将用户表中的数据根据用户ID范围分散到不同的数据库中。
* **简单随机**（Random）：将请求随机分发给后端服务器上，请求越多，各个服务器接收到的请求越平均
* 加权随机 (Weighted Random)：根据服务器自身的性能给服务器设置不同的权重，将请求按各个服务器的权重随机分发给后端服务器
* **最少连接算法**（Least Connection）：将请求分配给当前连接数最少的服务器，适合处理能力差异较大的服务器，能够有效防止某些服务器过载
* **最少活跃算法**：类似于最少连接，不过是以活动连接数为标准，即当前正在处理的请求数；活跃数越低，说明处理能力越强，这样就可以使处理能力强的服务器处理更多请求。
* **哈希算法**：将请求的参数信息通过哈希函数映射为一个哈希值，然后根据哈希值来决定请求被哪一台服务器处理。**在服务器数量不变的情况下**，相同参数的请求总是发到同一台服务器处理，有注意**利用缓存**，比如同个IP的请求、同一个用户ID的请求
  * $server\_idx = hash(user\_id) \% server\_num$
  * 问题：如果节点数量发生了变化，也就是在对系统做扩容或者缩容时，**必须迁移改变映射关系的数据**，否则会出现查询不到数据的问题；这个迁移成本太高了
* **一致性哈希算法**：解决了哈希算法在服务器数量变化后哈希值会落到不同服务器上的问题

#### 一致性哈希算法

一致哈希算法也用了取模运算，但与哈希算法不同的是，哈希算法是对节点的数量进行取模运算，而一致哈希算法是对$2^{32}$进行取模运算（即所谓哈希环）
![picture 8](../../images/5ae2f5fa08faf82705feed7a3d020648c782fbc7298cbd859de0eb0edcc2de2d.png){width=40%}

一致性哈希要进行两步哈希：

* 第一步：对**存储服务器节点**进行哈希计算，比如根据节点的IP地址进行哈希
* 第二步：当对**数据**进行存储或访问时，对数据进行哈希映射

所以，**一致性哈希是指将「存储节点」和「数据」都映射到一个首尾相连的哈希环上**

当需要对指定key的值进行读写时，也需要通过两步寻址：

* 对key进行哈希计算，确定key所在的位置: `hash(key) % (2^32-1)`
* **从该位置往顺时针的方向的找到第一个服务器节点就是要找的**

![picture 9](../../images/c769d84da2e0251dadeff5ac5a76fff994a058f27b32a9dd58c58cad5e1eba12.png){width=50%}

对于一致性哈希算法，如果你增加或移除了一个节点，**仅影响该节点在哈希环上顺时针的邻居节点的数据，其他数据不受影响**

一致性哈希算法存在的问题：**不保证节点能够在哈希环上分布均匀**，即会有大量的请求集中在一个节点上
解决方法：不再将真实节点映射到哈希环上，而是**将虚拟节点映射到哈希环上**，**并将虚拟节点映射到实际节点**，所以这里有「两层」映射关系。
![picture 10](../../images/bcb7570d2999addf8d2df4103224156643fd25d7742a1fc0eeee362872422151.png){width=40%}

### 服务端/七层负载均衡 vs. 客户端负载均衡

主要是**部署位置和控制权**不同：

* 七层负载均衡通常部署在服务器端，控制权在服务器端
* 客户端负载均衡由客户端直接实施，负载均衡逻辑集成在客户端的代码中，控制权在客户端；客户端根据服务实例的健康状况、负载情况等指标来决定选择哪个节点进行调用

七层负载均衡解决方案：

* **DNS解析**：在DNS服务器中**为同一个主机记录配置多个IP地址**，这些IP地址对应不同的服务器。当用户请求域名的时候，DNS服务器采用轮询算法返回IP地址，这样就实现了轮询版负载均衡
* **反向代理**：客户端将请求发送到反向代理服务器，由反向代理服务器去选择目标服务器，获取数据后再返回给客户端。**对外暴露的是反向代理服务器地址**，隐藏了真实服务器IP地址。反向代理“代理”的是目标服务器，这一个过程**对于客户端而言是透明的**
  * Nginx是最常见的反向代理服务器

客户端负载均衡一般通过现成的组件来实现：

* Netflix Ribbon: 更全面；Nacos中集成了Ribbon
* Spring Cloud Load Balancer

## 网关

> 建议再看一遍[link](https://www.bilibili.com/video/BV1S142197x7?t=538.5&p=58)

