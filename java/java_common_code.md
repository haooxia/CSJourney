# some common/important code in Java

## 生产者消费者问题

### 实现

> * bg: 经典的多线程并发协作模式，一个生产者线程用于生产数据，一个消费者线程用于消费数据，**为了解耦二者的关系**，通常采用一个共享的数据区域；ie 生产者生产数据后直接放到共享数据区，无需关心消费者的行为；消费者只需从共享数据区拿数据，无需关注生产者行为。（好一个解耦
> * 其中同步互斥关系：生产者之间互斥，消费者之间也互斥；生产者和消费者之间**互斥且同步**

**逻辑等待->业务->通知**

* 基于`synchronized + wait() + notify()`实现
  * wait()和notify()调用之前，**要求线程必须获得该对象的监视器锁，即只能在同步方法或方法块中调用二者**（wait执行完毕 当前线程会释放锁
  * notify()会从WAITTING状态的线程中挑选一个进行通知，使其从等待队列切换到同步队列，**然后还要等待获取对象的监视器锁**之后才可以执行；notifyall()会唤醒所有等待线程（包括生产者类和消费者类）
  * 缺陷：==无法实现精确唤醒，只能同时唤醒两类==
* 基于`Lock + Condition (await() & signal())`实现
  * **可以精确地唤醒一类线程**（可实现仅唤醒消费者类线程或生产者类线程）
    * 就是依赖多个condition
* 基于阻塞队列`BlockingQueue`实现
  * 无脑调用take()和put()即可，底层已经实现了互斥同步机制，它的底层思路就是`Lock + Condition`实现的，和我写的差不多...

### 应用场景

![picture 0](../images/f2c42349e2c03fcadf313cf93cad388b6a635df7cdfd30a2753401b6a197043b.png)  
![picture 1](../images/73d2f1223cfe1efe57084219ed1cf3b5b8b4abea3df2d0af1f8db4c8d85317da.png)  
